<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>타입스크립트의 타입 시스템 | sso214&#39;s TIL</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Today I Learned">
    
    <link rel="preload" href="/TIL/assets/css/0.styles.0a1e057f.css" as="style"><link rel="preload" href="/TIL/assets/js/app.2d66ab00.js" as="script"><link rel="preload" href="/TIL/assets/js/2.5e3b8e3c.js" as="script"><link rel="preload" href="/TIL/assets/js/124.f373a65b.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.fd93f209.js"><link rel="prefetch" href="/TIL/assets/js/100.aeb1a7a8.js"><link rel="prefetch" href="/TIL/assets/js/101.a0533b10.js"><link rel="prefetch" href="/TIL/assets/js/102.91e3bbd1.js"><link rel="prefetch" href="/TIL/assets/js/103.94bdec44.js"><link rel="prefetch" href="/TIL/assets/js/104.59ed2fb5.js"><link rel="prefetch" href="/TIL/assets/js/105.a670a608.js"><link rel="prefetch" href="/TIL/assets/js/106.a434600e.js"><link rel="prefetch" href="/TIL/assets/js/107.59a140c2.js"><link rel="prefetch" href="/TIL/assets/js/108.ab391b9e.js"><link rel="prefetch" href="/TIL/assets/js/109.b696ee94.js"><link rel="prefetch" href="/TIL/assets/js/11.1dabe5ed.js"><link rel="prefetch" href="/TIL/assets/js/110.01559fa4.js"><link rel="prefetch" href="/TIL/assets/js/111.b471510a.js"><link rel="prefetch" href="/TIL/assets/js/112.09e1399f.js"><link rel="prefetch" href="/TIL/assets/js/113.4e7018d1.js"><link rel="prefetch" href="/TIL/assets/js/114.21b6f9ab.js"><link rel="prefetch" href="/TIL/assets/js/115.1915d330.js"><link rel="prefetch" href="/TIL/assets/js/116.980f3ad7.js"><link rel="prefetch" href="/TIL/assets/js/117.c255c74c.js"><link rel="prefetch" href="/TIL/assets/js/118.a3cd9684.js"><link rel="prefetch" href="/TIL/assets/js/119.fc7a137b.js"><link rel="prefetch" href="/TIL/assets/js/12.bfc00192.js"><link rel="prefetch" href="/TIL/assets/js/120.b5027dff.js"><link rel="prefetch" href="/TIL/assets/js/121.f6994a77.js"><link rel="prefetch" href="/TIL/assets/js/122.70b88510.js"><link rel="prefetch" href="/TIL/assets/js/123.7277c315.js"><link rel="prefetch" href="/TIL/assets/js/125.0be19ecf.js"><link rel="prefetch" href="/TIL/assets/js/126.c82a57a6.js"><link rel="prefetch" href="/TIL/assets/js/127.64133d3a.js"><link rel="prefetch" href="/TIL/assets/js/128.f82a2db0.js"><link rel="prefetch" href="/TIL/assets/js/129.a6572a07.js"><link rel="prefetch" href="/TIL/assets/js/13.c7e97044.js"><link rel="prefetch" href="/TIL/assets/js/14.2b4e1db1.js"><link rel="prefetch" href="/TIL/assets/js/15.fe11e0f2.js"><link rel="prefetch" href="/TIL/assets/js/16.7a83084d.js"><link rel="prefetch" href="/TIL/assets/js/17.2a9ccd78.js"><link rel="prefetch" href="/TIL/assets/js/18.5efe031e.js"><link rel="prefetch" href="/TIL/assets/js/19.3565deac.js"><link rel="prefetch" href="/TIL/assets/js/20.1212a749.js"><link rel="prefetch" href="/TIL/assets/js/21.f89901e5.js"><link rel="prefetch" href="/TIL/assets/js/22.4bd24487.js"><link rel="prefetch" href="/TIL/assets/js/23.20ee24c6.js"><link rel="prefetch" href="/TIL/assets/js/24.8bdc8ccd.js"><link rel="prefetch" href="/TIL/assets/js/25.c0eb55ec.js"><link rel="prefetch" href="/TIL/assets/js/26.6b3aec63.js"><link rel="prefetch" href="/TIL/assets/js/27.a0be0573.js"><link rel="prefetch" href="/TIL/assets/js/28.bce3c0c7.js"><link rel="prefetch" href="/TIL/assets/js/29.78c8c53f.js"><link rel="prefetch" href="/TIL/assets/js/3.3866a126.js"><link rel="prefetch" href="/TIL/assets/js/30.0397d79d.js"><link rel="prefetch" href="/TIL/assets/js/31.d6242e35.js"><link rel="prefetch" href="/TIL/assets/js/32.e098946c.js"><link rel="prefetch" href="/TIL/assets/js/33.ae658251.js"><link rel="prefetch" href="/TIL/assets/js/34.a12a894d.js"><link rel="prefetch" href="/TIL/assets/js/35.66d90611.js"><link rel="prefetch" href="/TIL/assets/js/36.9bed69be.js"><link rel="prefetch" href="/TIL/assets/js/37.88582c54.js"><link rel="prefetch" href="/TIL/assets/js/38.e19ddc62.js"><link rel="prefetch" href="/TIL/assets/js/39.361bb521.js"><link rel="prefetch" href="/TIL/assets/js/4.fa83c5fa.js"><link rel="prefetch" href="/TIL/assets/js/40.8d1b9a96.js"><link rel="prefetch" href="/TIL/assets/js/41.f46a1685.js"><link rel="prefetch" href="/TIL/assets/js/42.9ba8c124.js"><link rel="prefetch" href="/TIL/assets/js/43.485c0f89.js"><link rel="prefetch" href="/TIL/assets/js/44.8237af5f.js"><link rel="prefetch" href="/TIL/assets/js/45.5a0cd42e.js"><link rel="prefetch" href="/TIL/assets/js/46.20b5bc42.js"><link rel="prefetch" href="/TIL/assets/js/47.eac5fd8a.js"><link rel="prefetch" href="/TIL/assets/js/48.75fe3a69.js"><link rel="prefetch" href="/TIL/assets/js/49.e6dab4a0.js"><link rel="prefetch" href="/TIL/assets/js/5.01799cc0.js"><link rel="prefetch" href="/TIL/assets/js/50.9aead8f6.js"><link rel="prefetch" href="/TIL/assets/js/51.bd5097d5.js"><link rel="prefetch" href="/TIL/assets/js/52.8ffa5024.js"><link rel="prefetch" href="/TIL/assets/js/53.1f5748c7.js"><link rel="prefetch" href="/TIL/assets/js/54.53a721ad.js"><link rel="prefetch" href="/TIL/assets/js/55.860ee171.js"><link rel="prefetch" href="/TIL/assets/js/56.c6ba3b92.js"><link rel="prefetch" href="/TIL/assets/js/57.14946c9c.js"><link rel="prefetch" href="/TIL/assets/js/58.53e3f045.js"><link rel="prefetch" href="/TIL/assets/js/59.febd9f48.js"><link rel="prefetch" href="/TIL/assets/js/6.852d803a.js"><link rel="prefetch" href="/TIL/assets/js/60.783d9c99.js"><link rel="prefetch" href="/TIL/assets/js/61.5b166cb9.js"><link rel="prefetch" href="/TIL/assets/js/62.df2cd4b8.js"><link rel="prefetch" href="/TIL/assets/js/63.a30e2eb2.js"><link rel="prefetch" href="/TIL/assets/js/64.cd8173ac.js"><link rel="prefetch" href="/TIL/assets/js/65.6c161d3e.js"><link rel="prefetch" href="/TIL/assets/js/66.aa6492d4.js"><link rel="prefetch" href="/TIL/assets/js/67.177bd55a.js"><link rel="prefetch" href="/TIL/assets/js/68.d94beaf8.js"><link rel="prefetch" href="/TIL/assets/js/69.73b32b36.js"><link rel="prefetch" href="/TIL/assets/js/7.9af980e7.js"><link rel="prefetch" href="/TIL/assets/js/70.a59302ea.js"><link rel="prefetch" href="/TIL/assets/js/71.0a33fc06.js"><link rel="prefetch" href="/TIL/assets/js/72.9eaa2956.js"><link rel="prefetch" href="/TIL/assets/js/73.c82b0d4a.js"><link rel="prefetch" href="/TIL/assets/js/74.c473463b.js"><link rel="prefetch" href="/TIL/assets/js/75.c1a54599.js"><link rel="prefetch" href="/TIL/assets/js/76.25fb58ae.js"><link rel="prefetch" href="/TIL/assets/js/77.e3c10501.js"><link rel="prefetch" href="/TIL/assets/js/78.92c0388c.js"><link rel="prefetch" href="/TIL/assets/js/79.1bfc1741.js"><link rel="prefetch" href="/TIL/assets/js/8.2cb1556f.js"><link rel="prefetch" href="/TIL/assets/js/80.88650c6c.js"><link rel="prefetch" href="/TIL/assets/js/81.12d61cc8.js"><link rel="prefetch" href="/TIL/assets/js/82.5e75256c.js"><link rel="prefetch" href="/TIL/assets/js/83.89d9a6cd.js"><link rel="prefetch" href="/TIL/assets/js/84.45a288b8.js"><link rel="prefetch" href="/TIL/assets/js/85.b097c70c.js"><link rel="prefetch" href="/TIL/assets/js/86.15ed7e54.js"><link rel="prefetch" href="/TIL/assets/js/87.f5a1007e.js"><link rel="prefetch" href="/TIL/assets/js/88.2b44cc13.js"><link rel="prefetch" href="/TIL/assets/js/89.41b684dc.js"><link rel="prefetch" href="/TIL/assets/js/9.89e644e4.js"><link rel="prefetch" href="/TIL/assets/js/90.6ae816a6.js"><link rel="prefetch" href="/TIL/assets/js/91.fec85b13.js"><link rel="prefetch" href="/TIL/assets/js/92.d82766cd.js"><link rel="prefetch" href="/TIL/assets/js/93.dd54bb63.js"><link rel="prefetch" href="/TIL/assets/js/94.7994abfa.js"><link rel="prefetch" href="/TIL/assets/js/95.f0259cd4.js"><link rel="prefetch" href="/TIL/assets/js/96.3f4b5cc0.js"><link rel="prefetch" href="/TIL/assets/js/97.bca7515f.js"><link rel="prefetch" href="/TIL/assets/js/98.f271fd38.js"><link rel="prefetch" href="/TIL/assets/js/99.d4610343.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.0a1e057f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">sso214's TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/TIL/study/" class="nav-link">
  Study
</a></div><div class="nav-item"><a href="/TIL/log/" class="nav-link">
  Log
</a></div><div class="nav-item"><a href="/TIL/memo/" class="nav-link">
  Memo
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="sso214" class="dropdown-title"><span class="title">sso214</span> <span class="arrow down"></span></button> <button type="button" aria-label="sso214" class="mobile-dropdown-title"><span class="title">sso214</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/TIL/info/" class="nav-link">
  Info
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/sso214" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/TIL/study/" class="nav-link">
  Study
</a></div><div class="nav-item"><a href="/TIL/log/" class="nav-link">
  Log
</a></div><div class="nav-item"><a href="/TIL/memo/" class="nav-link">
  Memo
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="sso214" class="dropdown-title"><span class="title">sso214</span> <span class="arrow down"></span></button> <button type="button" aria-label="sso214" class="mobile-dropdown-title"><span class="title">sso214</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/TIL/info/" class="nav-link">
  Info
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/sso214" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/TIL/Study/" aria-current="page" class="sidebar-link">Study</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Django</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Etc</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ReactNative</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="타입스크립트의-타입-시스템"><a href="#타입스크립트의-타입-시스템" class="header-anchor">#</a> 타입스크립트의 타입 시스템</h1> <p>2023.01.13</p> <h2 id="_6-편집기를-사용해-타입-시스템-탐색하기"><a href="#_6-편집기를-사용해-타입-시스템-탐색하기" class="header-anchor">#</a> 6. 편집기를 사용해 타입 시스템 탐색하기</h2> <p>타입스크립트 설치 시, 두 가지를 실행할 수 있음</p> <ul><li>tsc : 타입스크립트 컴파일러</li> <li>tsserver : 단독으로 실행 가능한 타입스크립트 서버</li></ul> <p>보통 TS 컴파일러 실행이 목적이지만, TS 서버는 '언어 서비스'를 제공한다는 점에서 중요.<br>
(언어 서비스는 코드 자동 완성, 명세 검사, 검색, 리펙터링이 포함됨.<br>
따라 타입스크립트 서버에서 언어 서비스를 제공하도록 설정하는게 좋음)</p> <ul><li>IDE에서 TS 언어 서비스를 적극 활용하는 것을 권장</li> <li>편집기를 사용하면 타입 시스템이 어떻게 동작하는지,<br>
TS가 어떻게 타입을 추론하는지 개념을 잡을 수 있음</li> <li>TS가 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 보는데 익숙해져야 함</li></ul> <h2 id="_7-타입이-값들의-집합이라고-생각하기"><a href="#_7-타입이-값들의-집합이라고-생각하기" class="header-anchor">#</a> 7. 타입이 값들의 집합이라고 생각하기</h2> <ul><li>타입을 값의 집합으로 생각하면 이해하기 편함 (타입의 '범위')<br>
이 집합은 유한(boolean 또는 리터럴)하거나 무한(number 또는 string)함</li> <li>TS 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합(벤 다이어그램)으로 표현됨<br>
두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있음</li> <li>한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있음</li> <li>타입 연산은 집합의 범위에 적용됨<br>
A와 B의 교집합은 A의 범위와 B의 범위의 인터섹션(교집합)<br>
객체 타입에서는 A &amp; B인 값이 A와 B의 속성을 모두 가짐을 의미함</li> <li>'A는 B를 상속', 'A는 B에 할당 가능', 'A는 B의 서브타입'은<br>
'A는 B의 부분 집합'과 같은 말</li> <li>가장 작은 집합은 아무 값도 포함하지 않는 공집합 (=never 타입)<br>
never 타입으로 선언된 변수의 범위는 공집합이기 떄문에 아무 값도 할당 불가능함</li> <li>그 다음으로 작은 집합은 한 가지 값만 포함하는 타입 (=유닛타입이라고도 불리는 리터럴 타입)<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token string">'B'</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token string">'C'</span><span class="token punctuation">;</span>
</code></pre></div>두 개 혹은 세 개로 묶으려면 유니온 타입을 사용함<br>
(유니온 타입 = 값 집합들의 합집합)<br>
집합 관점에서 타입 체커의 주요 역할은 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것.<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">AB</span></span> <span class="token operator">=</span> <span class="token string">'A'</span> <span class="token operator">|</span> <span class="token string">'B'</span>
</code></pre></div></li></ul> <table><thead><tr><th style="text-align:left;">TS 용어</th> <th style="text-align:left;">집합 용어</th></tr></thead> <tbody><tr><td style="text-align:left;">never</td> <td style="text-align:left;">공집합</td></tr> <tr><td style="text-align:left;">리터럴 타입</td> <td style="text-align:left;">원소가 1개인 집합</td></tr> <tr><td style="text-align:left;">값이 T에 할당 가능</td> <td style="text-align:left;">값이 T의 원소</td></tr> <tr><td style="text-align:left;">T1이 T2에 할당 가능</td> <td style="text-align:left;">T1이 T2의 부분 집합</td></tr> <tr><td style="text-align:left;">T1이 T2를 상속</td> <td style="text-align:left;">T1이 T2의 부분 집합</td></tr> <tr><td style="text-align:left;">T1 | T2</td> <td style="text-align:left;">T1과 T2의 합집합</td></tr> <tr><td style="text-align:left;">T1 &amp; T2</td> <td style="text-align:left;">T1과 T2의 교집합</td></tr> <tr><td style="text-align:left;">unknown</td> <td style="text-align:left;">전체 집합</td></tr></tbody></table> <h2 id="_8-타입-공간과-값-공간의-심벌-구분하기"><a href="#_8-타입-공간과-값-공간의-심벌-구분하기" class="header-anchor">#</a> 8. 타입 공간과 값 공간의 심벌 구분하기</h2> <ul><li>이름이 같을 경우 타입인지 값인지 헷갈릴 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Cylinder</span> <span class="token punctuation">{</span> <span class="token comment">//타입으로 쓰임</span>
    radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//위 Cylinder와 이름은 같지만 값으로 쓰이며 서로 아무 관련도 없음   </span>
<span class="token keyword">const</span> <span class="token function-variable function">Cylinder</span> <span class="token operator">=</span> <span class="token punctuation">(</span>radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> radius<span class="token punctuation">,</span> height <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>상황에 따라 Cylinder는 타입으로 쓰일 수도 있고, 값으로 쓰일 수도 있음<br>
=&gt;<br> <code>instanceof</code>를 이용해 인수가 Cylinder 타입인지 체크하려는 경우,<br> <code>instanceof</code>는 JS의 런타임 연산자이고, 값에 대해 연산을 하기 때문에<br> <code>instanceof Cylinder</code>는 타입이 아닌 함수를 참조하게 됨 (오류 발생)</li> <li>한 심벌이 타입인지 값인지 한 눈에 파악이 어려우므로 어떤 형태로 쓰이는지 문맥을 살펴야 함<br>
일반적으로 type이나 interface 다음에 나오는 심벌은 타입인 반면,<br>
const, let 선언에 쓰이는 것은 값<br>
모든 값은 타입을 가지지만 타입은 값을 가지지 않음<br>
(type과 interface 같은 키워드는 타입 공간에만 존재함)</li> <li>두 공간에 대한 개념을 잡으려면 타입스크립트 플레이그라운드 활용을 추천<br>
TS 플레이그라운드는 TS소스로부터 변환된 JS 결과물을 보여줌<br>
컴파일 과정에서 타입 정보는 제거되므로 심벌이 사라진다면 그것은 타입에 해당됨</li> <li>TS 코드에서 타입과 값은 번갈아 나올 수 있음<br>
타입 선언<code>(:)</code> 또는 단언문<code>(as)</code> 다음 나오는 심벌은 타입,<br> <code>(=)</code> 다음에 나오는 모든 것은 값.<br> <code>'foo'</code>는 문자열 리터럴이거나, 문자열 리터럴 타입일 수 있음</li> <li>class와 enum 키워드는 상황에 따라 타입과 값 두 가지로 모두 사용될 수 있음.<br>
아래 예제에서 Cylinder 클래스는 타입으로 쓰임<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Cylinder</span> <span class="token punctuation">{</span>
    radius <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    height <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">calculateVolume</span><span class="token punctuation">(</span>shape<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>shape <span class="token keyword">instanceof</span> <span class="token class-name">Cylinder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        shape <span class="token comment">//정상, 타입은 Cylinder</span>
        shape<span class="token punctuation">.</span>radius<span class="token punctuation">;</span> <span class="token comment">//정상, 타입은 number</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>클래스가 타입으로 쓰일 떄는 형태(속성과 메서드)가 사용되지만,<br>
값으로 쓰일 때는 생성자가 사용됨</li> <li>연산자 중에서도 타입에서 쓰일 때와 값에서 쓰일 때 다른 기능을 하는 것들이 있음<br>
그 중 하나로 typeof를 들 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> p<span class="token punctuation">;</span> <span class="token comment">//타입은 Person</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> email<span class="token punctuation">;</span> <span class="token comment">//타입은 (p:Person, subject: string, body: string) =&gt; Response</span>

<span class="token keyword">const</span> v1 <span class="token operator">=</span> <span class="token keyword">typeof</span> p<span class="token punctuation">;</span> <span class="token comment">//값은 'object'</span>
<span class="token keyword">const</span> v2 <span class="token operator">=</span> <span class="token keyword">typeof</span> email<span class="token punctuation">;</span> <span class="token comment">//값은 'function'</span>
</code></pre></div><ul><li>타입의 관점에서 typeof는 값을 읽어 TS 타입을 반환함<br>
타입 공간의 typeof는 보다 큰 타입의 일부분으로 사용 가능하고,<br>
type 구문으로 이름을 붙이는 용도로 사용 가능함</li> <li>값의 관점에서 typeof는 JS 런타임의 typeof 연산자가 됨<br>
값 공간의 typeof는 대상 심벌의 런타임 타입을 가리키는 문자열을 반환하며,<br>
TS 타입과는 다름.<br>
JS의 런타입 타입 시스템은 TS의 정적 타입 시스템보다 훨씬 간단함<br>
TS 타입은 종류가 무수히 많은 반면, JS에는 6개의 런타입만 존재</li></ul></li> <li>class 키워드는 값과 타입 두 가지로 모두 사용 가능하기 때문에<br>
클래스에 대한 typeof는 상황에 따라 다르게 동작함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> v <span class="token operator">=</span> <span class="token keyword">typeof</span> Cylinder<span class="token punctuation">;</span> <span class="token comment">//값이 'function'</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> Cylinder<span class="token punctuation">;</span> <span class="token comment">//타입이 typeof Cylinder</span>
</code></pre></div>클래스가 JS에서는 실제 함수로 구현되기 때문에 첫번째 줄 값은 'function'이 됨<br>
두 번째 줄의 타입에서 중요한 것은 Cylinder가 인스턴스의 타입이 아니라는 점.<br>
실제로는 new 키워드를 사용할 때 볼 수 있는 생성자 함수<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">declare</span> <span class="token keyword">let</span> fn<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//타입이 Cylinder</span>
</code></pre></div>아래 코드처럼 instanceType 제너릭을 사용해 생성자 타입과 인스턴스 타입을 전환할 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> instanceType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> Cylinder<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">//타입이 Cylinder</span>
</code></pre></div></li> <li>속성 접근자인 <code>[]</code>는 타입으로 쓰일 때에도 동일하게 동작함<br>
인덱스 위치에는 유니오 타입과 기본형 타입을 포함한 어떤 타입이든 사용 가능함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">PersonEl</span> <span class="token operator">=</span> Person<span class="token punctuation">[</span><span class="token string">'first'</span> <span class="token operator">|</span> <span class="token string">'last'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//타입은 string</span>
<span class="token keyword">type</span> <span class="token class-name">Tuple</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> Date<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token keyword">type</span> <span class="token class-name">TupleEl</span> <span class="token operator">=</span> Tuple<span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//타입은 stirng | number | Date</span>
</code></pre></div></li> <li>두 공간 사이에서 다른 의미를 가지는 코드 패턴들이 있음<br>
TS 코드가 의도와 다르게 동작한다면 타입 공간과 값 공간을 혼동해 잘못 작성했을 가능성 있음
<ul><li>값으로 쓰이는 this는 JS의 this 키워드.<br>
타입으로 쓰이는 this는 일명 '다형성 this'라고 불리는 this의 TS 타입.<br>
서브 클래스의 메서드 체인을 구현할 떄 유용함</li> <li>값에서 <code>&amp;</code>와 <code>|</code>는 AND와 OR 비트 연산자.<br>
타입에서는 인터섹션과 유니온</li> <li>const는 새 변수를 선언하지만,<br>
as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꿈</li> <li>extends는 서브클래스(<code>class A extends B</code>) 또는 서브타입(<code>inteface A extends B</code>)<br>
또는 제너릭 타입의 한정자(<code>Generic&lt;T extends number&gt;</code>)를 정의할 수 있음</li> <li>in은 루프(<code>for(key in object)</code>) 또는 매핑된 타입에 등장함</li></ul></li></ul> <h2 id="_9-타입-단언보다는-타입-선언을-사용하기"><a href="#_9-타입-단언보다는-타입-선언을-사용하기" class="header-anchor">#</a> 9. 타입 단언보다는 타입 선언을 사용하기</h2> <ul><li><p>TS에서 변수에 값을 할당하고 타입을 부여하는 방법은 2가지</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> alice<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'Alice'</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//타입은 Person</span>
<span class="token keyword">const</span> bob <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'Bob'</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Person<span class="token punctuation">;</span> <span class="token comment">//타입은 Person</span>
</code></pre></div><p>두 가지 타입은 결과가 같아 보이지만 그렇지 않음.</p> <ul><li><code>:Type</code>은 변수에 '타입 선언'을 붙여 그 값이 선언된 타입임을 명시함</li> <li>두 번째 as Type은 '타입 단언'을 수행함<br>
즉, TS가 추론한 타입이 있더라도 Person 타입으로 간주함</li></ul></li> <li><p>타입 단언 (<code>as Type</code>)보다 타입 선언(<code>: Type</code>) 사용을 권장함<br>
타입 선언은 할당되는 값이 해당 인터페이스를 만족했는지 검사하고 에러를 표시하지만,<br>
타입 단언은 강제로 타입을 지정하므로 타입 체커가 오류를 무시함</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> alice<span class="token operator">:</span>Person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다.</span>
<span class="token keyword">const</span> bob <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Person<span class="token punctuation">;</span> <span class="token comment">//오류 없음</span>
</code></pre></div></li> <li><p>타입 선언과 단언의 차이는 속성 추가 시에도 마찬가지로 동작함<br>
타입 선언문에서는 잉여 속성 체크가 동작하지만, 단언문에서는 적용되지 않음<br>
따라 타입 단언이 꼭 필요한 경우가 아니라면, 안정성 체크가 되는 타입 선언 사용을 권장함</p></li> <li><p><code>const bob = &lt;Person&gt;{}</code>은 단언문의 원래 문법이며 <code>{} as Person</code>과 동일함<br>
이 코드는 <code>&lt;Person&gt;</code>이 .tsx 파일에서 컴포넌트 태그로 인식되기 때문에 현재는 잘 쓰이지 않음</p></li> <li><p>화살표 함수의 반환 타입을 명시하는 방법을 터득해야 함</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">//Person[]을 원했지만 결과는 string[];</span>
<span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'alice'</span><span class="token punctuation">,</span> <span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'jan'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>name <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//{name}에 타입 단언을 쓰면 문제가 해결될 것 같지만 런타임에 문제가 발생하게 됨 </span>
<span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'alice'</span><span class="token punctuation">,</span> <span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'jan'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>name <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span> <span class="token keyword">as</span> Person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'alice'</span><span class="token punctuation">,</span> <span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'jan'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>name <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//오류 없음</span>

<span class="token comment">//단언문을 쓰지 않고 화살표 함수 안에 타입과 함께 변수 선언하는 것이 가장 직관적</span>
<span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'alice'</span><span class="token punctuation">,</span> <span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'jan'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>name <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> person<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> person<span class="token punctuation">;</span> <span class="token comment">//타입은 Person[]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
코드를 좀더 간결하게 만들기 위해 변수 대신 화살표 함수의 반환 타입 선언
위의 코드와 동일한 체크를 수행함

여기서 소괄호는 매우 중요한 의미를 지니는데
(name):Person은 name의 타입이 없고 반환 타입이 Person이라고 명시함  
(name:Person)은 name의 타입이 Person임을 명시하고 반환 타입이 없기 때문에 오류가 발생함
*/</span>
<span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'alice'</span><span class="token punctuation">,</span> <span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'jan'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">:</span>Person <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//그러나 함수 호출 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야 함  </span>
<span class="token comment">//그래야 정확한 곳에 오류가 표시됨</span>
</code></pre></div></li> <li><p>타입 단언이 꼭 필요한 경우가 있음<br>
타입 체커가 추론한 타입보다 개발자가 판단하는 타입이 더 정확할 때.<br>
이런 경우 타입 단언문을 사용하는 것이 타당함</p> <ul><li><p>DOM 엘리먼트를 다룰 경우.<br>
TS는 DOM에 접근하지 못하므로 해당 엘리먼트가 버튼 엘리먼트인지 알지 못함</p></li> <li><p>자주 쓰이는 특별한 문법<code>(!)</code>을 사용해서 null이 아님을 단언하는 경우</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> elNull <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//타입은 HTMLElement | null  </span>
<span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">;</span> <span class="token comment">//타입은 HTMLElement</span>
</code></pre></div><p>접미사로 쓰인 !는 값이 null이 아니라는 단언문으로 해석됨.<br>
단언문은 컴파일 과정에 제거되므로, 타입 체커는 알지 못하지만 그 값이 null이 아니라고<br>
확실할 수 있는 경우 사용해야 함. 그렇지 않다면 null을 체커하는 조건문을 사용해야 함</p></li></ul></li> <li><p>타입 단언문으로 임의의 타입 간 변환을 할 수는 없음<br>
A가 B의 부분 집합일 경우에만 타입 단언문을 사용해 변환 가능<br>
(<code>HTMLElement | null -&gt; HTMLElement, EventTarget -&gt; ButtonElement</code>)<br>
하지만 서로의 서브 타입이 아닌 경우 변환 불가능함<br>
이런 오류를 해결하려면 unknown 타입을 사용해야 함<br>
모든 타입은 unknown의 서버 타입이기 떄문에 unknown이 포함된 단언문은 항상 동작함<br>
unknown 단언은 임의의 타입 간 변환을 가능하게 하지만, 뭔가 위험한 동작을 하고 있다는 걸 알 수 있음<br> <code>const el = document.body as unknown as Person; //정상</code></p></li></ul> <h2 id="_10-객체-래퍼-타입-피하기"><a href="#_10-객체-래퍼-타입-피하기" class="header-anchor">#</a> 10. 객체 래퍼 타입 피하기</h2> <ul><li>JS에는 기본형 값들에 대한 일곱 가지 타입 존재함<br>
기본형들은 불변이며 메서드를 가지지 않는다는 점에서 객체와 구분됨<br>
(string, number, boolean, null, undefined, symbol, bigint)</li> <li>그런데 기본형인 string의 경우 메서드를 가지고 있는 것처럼 보임<br> <code>'string'.charAt(3) //&quot;m&quot;</code> <ul><li>string 기본형에는 메서드가 없지만 JS에는 메서드를 가지는<br>
String 객체 타입이 정의되어 있으며, JS는 기본형과 객체 타입을 서로 자유롭게 변환함</li> <li>string 기본형에 charAt 같은 메서드 사용 시<br>
JS는 기본형을 String 객체로 래핑하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버림</li> <li>String.prototype 몽키-패치하면 위의 설명한 내용 내부적인 동작 관찰 가능</li></ul></li> <li>아래 코드에서 메서드 내의 this는 string 기본형이 아닌 String 객체 래퍼.<br>
String 객체는 직접 생성할 수도 있고 string 기본형처럼 동작함<br>
하지만 string 기본형과 String 객체 래퍼가 항상 동일하게 동작하는 것은 X.<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> originalCharAt <span class="token operator">=</span> String<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>charAt<span class="token punctuation">;</span>
String<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">charAt</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>pso<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">originalCharAt</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'primitive'</span><span class="token punctuation">,</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[String: 'primitive'] 'object'  3 m</span>
</code></pre></div><ul><li>String 객체는 오직 자신하고만 동일함<br> <code>&quot;hello&quot; === new String(&quot;hello&quot;) //false</code><br> <code>new String(&quot;hello&quot;) === new String(&quot;hello&quot;) //false</code></li> <li>객체 래퍼 타입의 자동변환은 어떤 속성을 기본형에 속성 추가 시 그 속성이 사라짐<br>
실제로는 x가 String 객체로 변환된 후 속성이 추가되었고, 속성이 추가된 객체는 버려진 것.
<code>x = &quot;hello&quot;; x.language = &quot;English&quot;; x.language; //undefined</code></li></ul></li> <li>다른 기본형에도 동일하게 래퍼 타입이 존재함 (null, undefined 제외)<br>
래퍼 타입들로 인해 기본형 값에 메서드를 사용할 수 있고, 정적 메서드도 사용 가능함<br>
그러나 보통은 래퍼 객체를 직접 생성할 필요 없음</li> <li>TS는 기본형과 객체 래퍼 타입을 별도로 모델링함<br>
string은 String에 할당할 수 있지만 String은 string에 할당할 수 없음</li> <li>기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야 함<br>
직접 사용하거나 인스턴스를 생성하는 것은 지양해야 함</li> <li>TS 객체 래퍼 타입은 지양하고 기본형 타입을 사용해야 함<br>
String 대신 string, Number 대신 number, Boolean 대신 boolean,<br>
Symbol 대신 symbol, BigInt 대신 bitint 사용</li></ul> <h2 id="_11-잉여-속성-체크의-한계-인지하기"><a href="#_11-잉여-속성-체크의-한계-인지하기" class="header-anchor">#</a> 11. 잉여 속성 체크의 한계 인지하기</h2> <ul><li>객체 리터럴을 변수에 할당하거나 매개변수로 전달 시 잉여 속성 체크가 수행됨<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">//예시 1</span>
<span class="token keyword">interface</span> <span class="token class-name">Room</span> <span class="token punctuation">{</span>
    numDoors<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    ceilingHeightFt<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> r<span class="token operator">:</span> Room <span class="token operator">=</span> <span class="token punctuation">{</span>
  numDoors<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  ceilingHeightFt<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
  elephant<span class="token operator">:</span> <span class="token string">'parent'</span> <span class="token comment">//오류 발생</span>
<span class="token punctuation">}</span>

<span class="token comment">//예시 2</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  numDoors<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  ceilingHeightFt<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
  elephant<span class="token operator">:</span> <span class="token string">'parent'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> r<span class="token operator">:</span> Room <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div></li> <li>예시 1처럼 타입이 명시된 변수에 객체 리터럴 할당 시 TS는 해당 타입의 속성이 있는지,<br>
그리고 그 외의 속성은 없는지 확인함</li> <li>하지만 구조적 타이핑 관점으로 생각해보면 그 외의 속성이 있어도 오류가 발생하지 않아야 함.<br>
임시 변수를 도입해보면 알 수 있는데, 예시 2처럼 obj 객체는 Room 타입에 할당 가능함<br>
obj 타입은 Room 타입의 부분 집합을 포함하므로 Room에 할당 가능하며 타입체커도 통과함</li> <li>예시 1에서는 구조적 타입 시스템에서 발생할 수 있는 중요한 종류의 오류를 잡을 수 있도록<br>
'잉여 속성 체크'라는 과정이 수행되었음</li> <li>그러나 잉여 속성 체크 역시 조건에 따라 동작하지 않다는 한계가 있고,<br>
통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워질 수 있음<br>
따라 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야 함</li> <li><code>inteface Options { title: string; darkMode?: boolean }</code><br>
Options 타입의 경우 darkMode 속성에 boolean 타입이 아닌<br>
다른 타입의 값이 지정된 경우를 제외하면, string 타입인 title 속성과<br>
'또 다른 어떤 속성'을 가지는 모든 객체는 Options 타입의 범위에 속하기 때문에<br>
타입의 범위가 너무 넓어져 순수한 타입 체커는 대소문자 체크 같은 종류의 오류를 찾아내지 못함<br>
(ex, document, new HTMLAnchorElement 인스턴스는 모두<br>
string 타입인 title 속성을 가지고 있기 때문에 Options 타입 변수에 할당 가능함)<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> o1<span class="token operator">:</span> Options <span class="token operator">=</span> document<span class="token punctuation">;</span> <span class="token comment">//정상  </span>
<span class="token keyword">const</span> o2<span class="token operator">:</span> Options <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTMLAnchorElement</span><span class="token punctuation">;</span> <span class="token comment">//정상  </span>
</code></pre></div></li> <li>잉여 속성 체크를 이요하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도<br>
객체 리터럴에 알 수 없는 속성을 허용치 않음으로써 위에서 다룬 Room이나 Options 같은<br>
문제점을 방지할 수 있음 (=엄격한 객체 리터럴 체크)</li> <li>잉여 속성 체크는 객체리터럴이 아닐 경우 또는 타입 단언문을 사용할 경우 적용되지 않음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">//타입 구문 없는 임시 변수 사용</span>
<span class="token keyword">const</span> intermediate <span class="token operator">=</span> <span class="token punctuation">{</span> darkmode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">'Ski Free'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> o1<span class="token operator">:</span> Options <span class="token operator">=</span> intermediate<span class="token punctuation">;</span> <span class="token comment">//정상</span>
  
<span class="token comment">//객체리터럴 사용</span>
<span class="token keyword">const</span> o2<span class="token operator">:</span> Options <span class="token operator">=</span> <span class="token punctuation">{</span> darkmode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">'Ski Free'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//Error : Option 형식에 darkmode가 없습니다.</span>
  
<span class="token comment">//타입 단언문 사용</span>
<span class="token keyword">const</span> o3 <span class="token operator">=</span> <span class="token punctuation">{</span> darkmode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">'Ski Free'</span> <span class="token punctuation">}</span> <span class="token keyword">as</span> Options<span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div></li> <li>잉여 속성 체크를 원치 않는다면,<br>
인덱스 시그니처를 사용해 TS가 추가적인 속성을 예상하도록 할 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Options</span> <span class="token punctuation">{</span> 
  darkMode<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>otherOptions<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> o1 <span class="token operator">=</span> Options <span class="token operator">=</span> <span class="token punctuation">{</span>darkmode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div></li> <li>선택적 속성만 가지는 약한(weak) 타입에도 잉여 속성 체크와 비슷한 체크가 동작함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">LineChartOptions</span> <span class="token punctuation">{</span>
  logsacle<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  invertedYAxis<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  areaChart<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> opts <span class="token operator">=</span> <span class="token punctuation">{</span> logScale<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> o2<span class="token operator">:</span> LineChartOptions <span class="token operator">=</span> opts<span class="token punctuation">;</span> <span class="token comment">//Error : { logScale: boolean } 유형에 LineChartOptions 유형과 공통적인 속성이 없습니다.</span>
</code></pre></div>구조적 관점에서 LineChartOptions 타입은 모든 속성이 선택적이므로 모든 객체를 포함 가능함<br>
이런 약한 타입에 대해 TS는 값 타입과 선언 타입에 공통된 속성이 있는지<br>
확인하는 별도의 체크를 수행함 (=공통 속성 체크)<br> <br>
공통 속성 체크는 잉여 속성 체크와 마찬가지로 오타를 잡는데 효과적이며 구조적으로 엄격하지 않음<br>
그러나 잉여 속성 체크와는 달리 약한 타입과 관련된 할당문마다 수행됨<br>
임시 변수를 제거하더라도 공통 속성 체크는 여전히 동작함</li> <li>잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름의 오타 같은 실수를 잡는데 효과적.<br>
선택적 필드를 포함하는 Options 같은 타입에 특히 유용한 반면,<br>
적용 범위가 매우 제한적이며 오직 객체 리터럴에만 적용됨 (임시 변수 도입 시 잉여 속성 체크 건너뜀)<br>
따라 한계점을 인지하고 잉여 속성 체크와 일반적인 타입 체크를 구분해 사용 필요</li></ul> <h2 id="_12-함수-표현식에-타입-적용하기"><a href="#_12-함수-표현식에-타입-적용하기" class="header-anchor">#</a> 12. 함수 표현식에 타입 적용하기</h2> <ul><li>JS, TS에서는 함수 문장과 함수 표현식을 다르게 인식함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">rollDice1</span><span class="token punctuation">(</span>sides<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//문장</span>
<span class="token keyword">const</span> <span class="token function-variable function">rollDice2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>sides<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//표현식</span>
<span class="token keyword">const</span> rollDice3 <span class="token operator">=</span> <span class="token punctuation">(</span>sides<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//표현식</span>
</code></pre></div></li> <li>TS에서는 함수 표현식 사용을 권장함<br>
함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언해 함수 표현식에 재사용 가능하기 떄문<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">DiceRollFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>sides<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> rollDice<span class="token operator">:</span> <span class="token function-variable function">DiceRollFn</span> <span class="token operator">=</span> sides <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>함수 타입의 선언은 불필요한 코드의 반복을 줄임<br>
함수 타입 선언을 이용했던 예제보다 타입 구분이 적으며, 함수 구현부도 분리되어 로직이 분명해짐<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">//함수 타입 선언 사용</span>
<span class="token keyword">function</span> <span class="token function">add1</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">sub1</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">mul1</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">div1</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//반복되는 함수 시그니처를 하나의 함수 타입으로 통합</span>
<span class="token keyword">type</span> <span class="token class-name">BinaryFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> add2<span class="token operator">:</span> <span class="token function-variable function">BinaryFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token keyword">const</span> sub2<span class="token operator">:</span> <span class="token function-variable function">BinaryFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
<span class="token keyword">const</span> mul2<span class="token operator">:</span> <span class="token function-variable function">BinaryFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
<span class="token keyword">const</span> div2<span class="token operator">:</span> <span class="token function-variable function">BinaryFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
</code></pre></div></li> <li>라이브러리는 공통 함수 시그니처를 타입으로 제공하기도 함<br>
ex)<br>
리액트는 함수의 매개변수에 명시하는 MouseEvent 타입 대신<br>
함수 전체에 적용 가능한 MouseEventHandler 타입을 제공함<br>
라이브러리를 제작하고 있다면 공통 콜백함수를 위한 타입 선언 제공을 권장함</li> <li>시그니처가 일치하는 다른 함수가 있을 때도 함수 표현식에 타입을 적용하면 좋음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 상태 체크를 수행해 줄 checkedFetch 함수 작성</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">fetch</span><span class="token punctuation">(</span>input<span class="token operator">:</span> RequestInfo<span class="token punctuation">,</span> init<span class="token operator">?</span><span class="token operator">:</span> RequestInit<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Response<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">cehckedFetch</span><span class="token punctuation">(</span>input<span class="token operator">:</span> RequestInfo<span class="token punctuation">,</span> init<span class="token operator">?</span><span class="token operator">:</span> RequestInit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>response<span class="token punctuation">.</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Request Failed : '</span> <span class="token operator">+</span> response<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> response<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 함수 표현식으로 바꾸고 함수 전체에 타입(typeof fetch)을 적용해서 더 간결해 작성</span>
<span class="token comment">// TS가 input과 init의 타입을 추론할 수 있게 하며, 반환 타입을 보장하고 fetch와 동일함 </span>
<span class="token comment">// 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 됨</span>
<span class="token keyword">const</span> checkedFetch<span class="token operator">:</span> <span class="token keyword">typeof</span> <span class="token function-variable function">fetch</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>input<span class="token punctuation">,</span> init<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>response<span class="token punctuation">.</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Request Failed : '</span> <span class="token operator">+</span> response<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> response<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>에러를 throw가 아닌 return을 사용할 경우 <code>Promise&lt;Response | Error&gt;</code>형식은<br> <code>Promise&lt;Response&gt;</code> 형식에 할당할 수 없기 떄문에 오류가 발생하는데<br>
위의 함수 문장으로 정의한 cehckedFetch 함수는 구현체가 아닌 함수 호출 위치에서 에러가 발생함<br>
반면 함수표현식으로 작성한 아래 cehckedFetch 함수는 Fetch 구현체에서 에러가 발생함</li> <li>함수의 매개변수에 타입 선언을 하는 것보다 함수 표현식 전체 타입을 정의하는 편이 코드도 간결하고 안전함<br>
따라 다른 함수의 시그니처와 동일한 타입을 가지는 새 함수를 작성하거나,<br>
동일한 타입 시그니처를 가지는 여러개의 함수 작서잇에는 함수 전체의 타입 선언 적용을 권장함</li></ul> <h2 id="_13-타입과-인터페이스의-차이점-알기"><a href="#_13-타입과-인터페이스의-차이점-알기" class="header-anchor">#</a> 13. 타입과 인터페이스의 차이점 알기</h2> <ul><li>TS에서 명명된 타입을 정의하는 방법은 2가지가 존재<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">//type으로 named type 정의</span>
<span class="token keyword">type</span> <span class="token class-name">TState</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    capital<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//inteface로 named type 정의</span>
<span class="token keyword">interface</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    capital<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre></div>(인터페이스 대신 클래스를 사용할 수도 있음)</li> <li>대부분의 경우 타입이나 인터페이스 둘 다 사용해도 되지만, 차이점을 정확히 알고<br>
같은 상황에서는 동일한 방법으로 명명된 타입을 정의해 일관성을 유지해야 함</li> <li>타입 네이밍 앞에 I(인터페이스) 또는 T(타입) 접두사를 붙이는 것은 C#에서 비롯된 관례.<br>
이 영향을 받아 TS 초기에는 종종 사용했지만 현재는 지양해야 할 스타일로 여겨짐<br>
표준 라이브러리에서도 일관성있게 도입되지 않았으므로 유용하지도 않음</li></ul> <h3 id="인터페이스와-타입-선언의-비슷한-점"><a href="#인터페이스와-타입-선언의-비슷한-점" class="header-anchor">#</a> 인터페이스와 타입 선언의 비슷한 점</h3> <ul><li>명명된 타입은 인터페이스로 정의했든 타입으로 정의했든 상태에는 차이 없음</li> <li>둘 다 모두 인덱스 시그니처 사용 가능<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">IDict</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">interface</span> <span class="token class-name">IDict</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>둘 다 모두 함수 타입으로 정의 가능<br>
단순한 함수 타입에는 타입 별칭 방법이 더 낫지만,<br>
함수 타입에 추가적인 속성이 있다면 둘 중 어느것을 선택하든 차이 없음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">TFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">interface</span> <span class="token class-name">IFn</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> toStrT<span class="token operator">:</span> <span class="token function-variable function">TFn</span> <span class="token operator">=</span> x <span class="token operator">=&gt;</span> <span class="token string">''</span> <span class="token operator">+</span> x<span class="token punctuation">;</span> <span class="token comment">//정상</span>
<span class="token keyword">const</span> toStrI<span class="token operator">:</span> <span class="token function-variable function">IFn</span> <span class="token operator">=</span> x <span class="token operator">=&gt;</span> <span class="token string">''</span> <span class="token operator">+</span> x<span class="token punctuation">;</span> <span class="token comment">//정상</span>

<span class="token comment">//문법이 생소할 수 있지만 JS에서 함수는 호출 가능한 객체이므로 납득 가능함</span>
<span class="token keyword">type</span> <span class="token class-name">TFnWithProperties</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">IFnWithProperties</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>타입 별칭과 인터페이스는 모두 제너릭 사용 가능<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">TPair<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    first<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    second<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">IPair<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  first<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  second<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>인터페이스와 타입 모두 확장 가능함<br>
(인터페이스는 주의사항이 몇 가지 있음)<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">IStateWithPop</span> <span class="token keyword">extends</span> <span class="token class-name">TState</span> <span class="token punctuation">{</span>
    population<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">TStateWithPop</span> <span class="token operator">=</span> IState <span class="token operator">&amp;</span> <span class="token punctuation">{</span> population<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>위의 IStateWithPop, TStateWithPop는 동일함<br>
여기서 주의해야할 점은 인터페이스는 유니온 타입 같은 복잡한 타입을 확장하지 못함<br>
(복잡한 타입을 확장하고 싶다면 타입과 &amp;를 사용해야 함)<br>
한편, 클래스를 구현(implements)할 때는, 타입(TState)과 인터페이스(IState) 둘 다 사용 가능함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">StateT</span> <span class="token keyword">implements</span> <span class="token class-name">TState</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
    capital<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">StateI</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
  capital<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="인터페이스와-타입-선언의-차이점"><a href="#인터페이스와-타입-선언의-차이점" class="header-anchor">#</a> 인터페이스와 타입 선언의 차이점</h3> <ul><li>유니온 타입은 있지만 유니온 인터페이스라는 개념은 없음<br> <code>type AorB = 'a' | 'b'</code>
유니은은 타입 확장을 할 수 없지만 유니온 타입 확장이 필요한 경우가 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">//별도의 타입을 하나의 변수명으로 매핑해 만든 인터페이스</span>
<span class="token keyword">type</span> <span class="token class-name">Input</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">interface</span> <span class="token class-name">VariableMap</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> Input <span class="token operator">|</span> Output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//유니온 타입에 name 속성을 붙인 타입</span>
<span class="token keyword">type</span> <span class="token class-name">NamedVariable</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Input <span class="token operator">|</span> Output<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>NamedVariable 타입은 인터페이스로 표현이 불가능함</li> <li>type 키워드는 일반적으로 interface보다 쓰임새가 많음<br>
type 키워드는 유니온이 될 수도 있고, 매핑된 타입 또는 조건부 타입 같은 고급 기능에 활용되기도 함<br>
튜플과 배열 타입도 type 키워드를 이용해 더 간결하게 표현 가능함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Pair</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">StringList</span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">NamedNums</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>nubmer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div>인터페이스도 튜플과 비슷하게 구현할 수 있기는 하지만<br>
튜플에서 사용 가능한 concat 같은 메서드들을 사용할 수 없음<br>
그러므로 튜플은 type 키워드로 구현해야 함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Tuple</span> <span class="token punctuation">{</span>
    <span class="token number">0</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token number">1</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    length<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> t<span class="token operator">:</span> Tuple <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div></li> <li>반면 인터페이스는 타입에 없는 몇 가지 기능 존재함<br>
그중 하나는 보강이 가능하다는 것.<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  capital<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>
  population<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> wyoming<span class="token operator">:</span> IState <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'Wyoming'</span><span class="token punctuation">,</span>
  capital<span class="token operator">:</span> <span class="token string">'Cheyenne'</span><span class="token punctuation">,</span>
  population<span class="token operator">:</span> <span class="token number">500_000</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div>이렇게 속성을 확장하는 것을 '선언 병합'이라고 함<br>
선언 병합은 주로 타입 선언 파일에서 사용됨<br>
따라 타입 선언 파일을 작성할 떄는 선언 병합을 지원하기 위해<br>
반드시 인터페이스를 사용해야 하며 표준을 따라야 함<br>
타입 선언에는 사용자가 채워야 하는 빈틈이 있을 수 있는데 바로 이 선언 병합이 그럼.</li> <li>TS는 여러 버전의 JS 표준 라이브러리에서 여러 타입을 모아 병합함<br>
예를 들어 Array 인터페이스는 lib.es5.d.ts에 정의되어 있고<br>
기본적으로는 lib.es5.d.ts에 선언된 인터페이스가 사용됨<br>
그러나 tsconfig.json의 lib 목록에 ES2015를 추가하면<br>
TS는 lib.es2015.d.ts에 선언된 인터페이스를 병합함<br>
여기에는 2015에 추가된 또 다른 Array 선언에 find 같은 메서드가 포함됨<br>
이들은 병합을 통해 다른 Array 인터페이스에 추가되고<br>
결과적으로 각 선언이 병합되어 전체 메서드를 가지는 하나의 Array 타입을 얻게 됨</li> <li>병합은 선언처럼 일반적인 코드라 언제든 가능하기 때문에<br>
프로퍼티가 추가되는 것을 원하지 않는다면 인터페이스 대신 타입을 사용해야 함</li></ul> <h3 id="결론"><a href="#결론" class="header-anchor">#</a> 결론</h3> <ul><li>복잡한 타입일 경우 고민할 것도 없이 타입 별칭 사용</li> <li>타입과 인터페이스 두 가지 방법으로 모두 표현 가능한 간단한 객체 타입이라면<br>
일관성과 보강의 관점에서 고려.<br>
일관되게 인터페이스를 사용하는 코드 베이스에서 작업하고 있는 경우 인터페이스를 사용,<br>
일관되게 타입을 사용 중이라면 타입을 사용</li> <li>아직 스타일이 확립되지 않은 프로젝트일 경우,<br>
향후 보강의 가능성이 있다면 인터페이스를 사용하는 것을 추천<br>
(API가 변경될 때 사용자가 인터페이스를 통해 새로운 필드를 병합할 수 있어 유용하기 때문)<br>
But, 프로젝트 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은<br>
잘못된 설계이므로 이런 경우 타입을 사용해야 함</li></ul> <h2 id="_14-타입-연산과-제너릭-사용으로-반복-줄이기"><a href="#_14-타입-연산과-제너릭-사용으로-반복-줄이기" class="header-anchor">#</a> 14. 타입 연산과 제너릭 사용으로 반복 줄이기</h2> <ul><li>DRY : Don't repeat yourself 원칙 (같은 코드를 반복하지 말라)<br>
타입 중복은 코드 중복만큼 많은 문제를 발생시킴<br>
따라 DRY 원칙을 타입에도 최대한 적용해야 함<br>
타입 간의 매핑하는 방법을 익히면 타입 정의에서도 DRY의 장점을 적용할 수 있음</li> <li>반복을 줄이는 가장 간단한 방법은 반복되는 타입에 이름을 붙이는 것<br>
상수를 사용해 반복을 줄이는 기법을 동일하게 타입 시스템에 적용한 것<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">distance</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x <span class="token operator">-</span> b<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>y <span class="token operator">-</span> b<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//타입이 이름 붙임</span>
<span class="token keyword">interface</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>
    x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">distance</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Point2D<span class="token punctuation">,</span> b<span class="token operator">:</span> Point2D<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>하지만 중복된 타입 찾기가 항상 쉬운 것은 아님<br>
중복된 타입은 종종 문법에 의해 가려지기도 하기 때문<br>
그럴 경우 해당 시그니처를 명명된 타입으로 분리할 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> opts<span class="token operator">:</span> Options<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Response<span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
<span class="token keyword">function</span> <span class="token function">post</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> opts<span class="token operator">:</span> Options<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Response<span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 

<span class="token keyword">type</span> <span class="token class-name">HTTPFunction</span> <span class="token operator">=</span> <span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> opts<span class="token operator">:</span> Options<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Response<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">get</span><span class="token operator">:</span> <span class="token function-variable function">HTTPFunction</span> <span class="token operator">=</span> <span class="token punctuation">(</span>url<span class="token punctuation">,</span> opts<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> post<span class="token operator">:</span> <span class="token function-variable function">HTTPFunction</span> <span class="token operator">=</span> <span class="token punctuation">(</span>url<span class="token punctuation">,</span> opts<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>한 인터페이스가 다른 인터페이스를 확장하게 해 반복을 제거할 수 있음<br>
extends를 사용해 인터페이스 필드의 반복을 피해야 함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    lastName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">PersonWithBirthDate</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    birth<span class="token operator">:</span> Date<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>만약 두 인터페이스가 필드의 부분 집합을 공유한다면, 공통 필드만 골라 기반 클래스로 분리해낼 수 있음<br>
또한 이미 존재하는 타입을 확장하는 경우 일반적이진 않지만 인터섹션 연산자를 사용할 수도 있음<br> <code>type PersonWithBirthDate = Person &amp; { birth: Date };</code><br>
이런 기법은 유니온 타입(확장할 수 없는)에 속성을 추가하려할 때 특히 유용함</li> <li>전체 애플리케이션의 상태를 표현하는 State 타입과 단지 부분만 표현하는 TopNavState 타입이 있는 경우<br>
TopNavState를 확장해 State를 구성하기보다,<br>
State의 부분 집합으로 TopNavState를 정의하는것이 효율적으로 보임<br>
이 방법이 전체 앱의 상태를 하나의 인터페이스로 유지할 수 있게 해줌<br>
따라 State를 인덱싱 해 속성의 타입에서 중복을 제거할 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
    userId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    pageTitle<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    recentFiles<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    pageContents<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">TopNavState</span> <span class="token punctuation">{</span>
  userId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  pageTitle<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  recentFiles<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// State를 인덱싱 해 속성의 타입에서 중복을 제거</span>
<span class="token keyword">type</span> <span class="token class-name">TopNavState</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  userId<span class="token operator">:</span> State<span class="token punctuation">[</span><span class="token string">'userId'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  pageTitle<span class="token operator">:</span> State<span class="token punctuation">[</span><span class="token string">'pageTitle'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  recentFiles<span class="token operator">:</span> State<span class="token punctuation">[</span><span class="token string">'recentFiles'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>이제 State 내의 pageTitle 타입이 변경되면 TopNavState에도 반영됨<br>
그러나 여전히 반복되는 코드 존재함<br>
이 경우 매핑된 타입을 사용하면 반복되는 코드 줄일 수 있음<br>
이 정의는 앞의 정의한 타입과 완전히 동일함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">TopNavState</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>k <span class="token keyword">in</span> <span class="token string">'userId'</span> <span class="token operator">|</span> <span class="token string">'pageTitle'</span> <span class="token operator">|</span> <span class="token string">'recentFiles'</span><span class="token punctuation">]</span><span class="token operator">:</span> State<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>매핑된 타입은 배열의 필드를 루프 도는 것과 같은 방식.<br>
이 패턴은 표준 라이브러리에서도 일반적으로 찾을 수 있으며 Pick이라고 함<br> <code>type Pick&lt;T, K&gt; = { [k in K]: T[K] };</code><br>
정의가 완전하지는 않지만 아래처럼도 사용 가능
<code>type TopNavState = Pick&lt;State, 'userId' | 'pageTitle' | 'recentFiles'&gt;;</code><br>
(여기서 Pick은 제너릭 타입)<br>
Pick은 T, K 두 가지 타입을 받아 결과 타입을 반환함</li> <li>태그된 유니온에서도 다른 형태의 중복 발생할 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">//단순히 태그를 붙이기 위해 타입을 사용할 경우</span>
<span class="token keyword">interface</span> <span class="token class-name">SaveAction</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span><span class="token operator">:</span> <span class="token string">'save'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">LoadAction</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span><span class="token operator">:</span> <span class="token string">'load'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Action</span> <span class="token operator">=</span> SaveAction <span class="token operator">|</span> LoadAction<span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">ActionType</span> <span class="token operator">=</span> <span class="token string">'save'</span> <span class="token operator">|</span> <span class="token string">'load'</span><span class="token punctuation">;</span> <span class="token comment">//타입 반복</span>

<span class="token comment">//Action 유니온을 인덱싱하면 타입 반복 없이 ActionType 정의 가능</span>
<span class="token keyword">type</span> <span class="token class-name">ActionType</span> <span class="token operator">=</span> Action<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//타입은 'save' | 'load'</span>
</code></pre></div>Action 유니온에 타입을 더 추가하면 ActionType은 자동적으로 그 타입을 포함함<br>
ActionType은 Pick을 사용해 얻게되는 type 속성을 가지는 인터페이스와는 다름
<code>type ActionRec = Pick&lt;Action, 'type'&gt;; //{type: 'save' | 'load'}</code></li> <li>생성하고 난 다음 업데이트가 되는 클래스를 정의한다면<br>
update 메서드 매개변수의 타입은 생성자와 동일한 매개변수이면서<br>
타입 대부분이 선택적 필드가 됨<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Options</span> <span class="token punctuation">{</span>
  width<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  color<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  loabel<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">OptionsUpdate</span> <span class="token punctuation">{</span>
  width<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  height<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  color<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  loabel<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">UIWidget</span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span>init<span class="token operator">:</span> Options<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">update</span><span class="token punctuation">(</span>options<span class="token operator">:</span> OptionsUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>매핑된 타입과 keyof를 사용하면 Options으로부터 OptionsUpdate를 만들 수 있음<br> <code>type OptionsUpdate = {[k in keyof Options]?: Options[k]};</code><br>
keyof는 타입을 받아 속성 타입의 유니온을 반환함<br> <code>type OptionsKeys = keyof Options; //'width' | 'height' | 'color' | 'label'</code><br>
매핑된 타입(<code>[k in keyof Options]</code>)은 순회하면 Options 내 k 값에 해당하는 속성이 있는지 찾음<br>
?는 각 속성을 선택적으로 만듬<br>
이 패턴 역시 아주 일반적이며 표준 라이브러리에 Partial라는 이름으로 포함되어 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">UIWidget</span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span>init<span class="token operator">:</span> Options<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">update</span><span class="token punctuation">(</span>options<span class="token operator">:</span> Partial<span class="token operator">&lt;</span>Options<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>값의 형태에 해당하는 타입을 정의하고 싶을 때는 typeof를 사용하면 됨<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> <span class="token constant">INIT_OPTIONS</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  width<span class="token operator">:</span> <span class="token number">640</span><span class="token punctuation">,</span>
  height<span class="token operator">:</span> <span class="token number">480</span><span class="token punctuation">,</span>
  color<span class="token operator">:</span> <span class="token string">'#00ff00'</span><span class="token punctuation">,</span>
  label<span class="token operator">:</span> <span class="token string">'VGA'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">Options</span> <span class="token punctuation">{</span>
  width<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  color<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  label<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Options</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> <span class="token constant">INIT_OPTIONS</span><span class="token punctuation">;</span> <span class="token comment">//위의 interface Options과 같음</span>
</code></pre></div>여기에서 사용한 typeof는 타입스크립트 단계에서 연산되며 훨씬 더 정확하게 타입을 표현함<br>
그런데 값으로부터 타입을 만들어낼 때는 선언에 순서에 주의해야 함<br>
타입 정의를 먼저하고 값이 그 타입에 할당 가능하다고 선언해야<br>
타입이 더 명확해지고 예상 어려운 타입 변동을 방지할 수 있음</li> <li>함수나 메서드의 반환값에 명명된 타입을 만들고 싶은 경우 ReturnType 제너릭을 사용<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">getUserInfo</span><span class="token punctuation">(</span>userId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    userId<span class="token punctuation">,</span>
    name<span class="token punctuation">,</span>
    age<span class="token punctuation">,</span>
    height<span class="token punctuation">,</span>
    weight<span class="token punctuation">,</span>
    favoriteColor
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//추론된 반환 타입은 {userId: string, name: string, ...}</span>

<span class="token keyword">type</span> <span class="token class-name">UserInfo</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> getUserInfo<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div>ReturnType은 함수의 값인 getUserInfo가 아니라 함수의 타입인 typeof getUserInfo에 적용됨<br>
(typeof와 마찬가지로 사용할 때 적용 대상이 값인지 타입인지 정확히 알고 구분해서 처리해야 함)</li> <li>제네릭 타입은 타입을 위한 함수와 같음<br>
(타입에 대한 DRY 원칙의 핵심은 제네릭)<br>
타입을 반복하는 대신 제너릭 타입을 사용해 타입들 간 매핑을 하는 것이 좋음<br>
함수에서 매개변수로 매핑할 수 있는 값을 제한하기 위해 타입 시스템을 사용하는 것처럼<br>
제네릭 타입에서 매개변수를 제한할 수 있는 방법이 필요함<br>
제네릭 타입을 제한하려면 extends를 사용하면 됨<br>
extends를 사용하면 제네릭 매개변수가 특정 타입을 확장한다고 선언할 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Name</span> <span class="token punctuation">{</span>
    first<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    last<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">DancingDuo<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Name<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> couple1<span class="token operator">:</span> DancingDuo<span class="token operator">&lt;</span>Name<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>first<span class="token operator">:</span> <span class="token string">'Fred'</span><span class="token punctuation">,</span> last<span class="token operator">:</span> <span class="token string">'Astaire'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>first<span class="token operator">:</span> <span class="token string">'Ginger'</span><span class="token punctuation">,</span> last<span class="token operator">:</span> <span class="token string">'Rogers'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//OK</span>

<span class="token keyword">const</span> couple2<span class="token operator">:</span> DancingDuo<span class="token operator">&lt;</span><span class="token punctuation">{</span>first<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token comment">// Name 타입에 필요한 last 속성이 {first: string;} 타입에 없습니다.</span>
  <span class="token punctuation">{</span>first<span class="token operator">:</span><span class="token string">'Sonny'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>first<span class="token operator">:</span><span class="token string">'Cher'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// {first: string}은 Name을 확장하지 않기 떄문에 오류가 발생함</span>
</code></pre></div>표준 라이브러리에 정의된 Pick, Partial, ReturnType 등의 제네릭 타입에 익숙해져야 함</li> <li>현재의 TS에서는 선언부에 항상 제너릭 매개변수를 작성하도록 되어 있음<br> <code>DancingDuo&lt;Name&gt;</code> 대신 <code>DancingDuo</code>를 쓰면 동작하지 않음<br>
TS가 제네릭 매개변수의 타입을 추론하게 하기 위해, 함수 작성시에는 신중하게 타입을 고려해야 함</li> <li>앞에 나온 Pick의 정의는 extends를 사용해 완성할 수 있음<br>
타입 체커를 통해 기존 예제를 실행해보면 오류 발생함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>k <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token comment">//K타입은 string | number | symbol 타입에 할당할 수 없습니다.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/*
K는 T타입과 무관하고 범위가 너무 넓음.
K는 인덱스로 사용 가능한 string | number | symbol이 되어야 하며
T의 키의 부분 집합, 즉 keyof T가 되어야 함
*/</span>
<span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>k <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div>타입이 값의 집합이라는 관점에서 생각하면 extends를 확장이 아닌 부분집합이라는 걸 이해 가능함</li></ul> <h2 id="_15-동적-데이터에-인덱스-시그니처-사용하기"><a href="#_15-동적-데이터에-인덱스-시그니처-사용하기" class="header-anchor">#</a> 15. 동적 데이터에 인덱스 시그니처 사용하기</h2> <ul><li>JS의 장점 중 하나는 객체를 생성하는 문법이 간단하다는 것.<br>
JS 객체는 문자열 키를 타입의 값에 관계없이 매핑함<br>
TS에서는 타입에 인덱스 시그니처를 명시해 유연하게 매핑을 표현할 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Rocket</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>property<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> trocket<span class="token operator">:</span> Rocket <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'Falcon 9'</span><span class="token punctuation">,</span>
  variant<span class="token operator">:</span> <span class="token string">'v1.0'</span><span class="token punctuation">,</span>
  thrust<span class="token operator">:</span> <span class="token string">'4,940 kN'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div></li> <li><code>[property: string]: string</code>이 인덱스 시그니처이며 세 가지 의미를 담고 있음
<ul><li>키의 이름 : 키의 위치만 표시하는 용도.<br>
타입 체커에서는 사용하지 않으므로 무시 가능한 참고 정보라고 생각하면 됨</li> <li>키의 타입 : string | number | symbol의 조합이어야 하지만 보통 string을 사용함</li> <li>값의 타입 : 어떤 타입이든 가능</li></ul></li> <li>이렇게 타입 체크가 수행되면 네 가지 단점이 드러남
<ul><li>잘못된 키를 포함해 모든 키를 허용함.<br>
(name대신 Name으로 작성해도 유효한 Rocket 타입이 됨)</li> <li>특정 키가 필요하지 않음
({}도 유효한 Rocket 타입이 됨)</li> <li>키마다 다른 타입을 가질 수 없음</li> <li>TS 언어 서비스가 도움이 되지 못함<br>
(name: 입력 시 키는 무엇이든 가능하기 떄문에 자동 완성 기능 동작하지 않음)</li></ul></li> <li>따라 인덱스 시그니처는 부정확하므로 더 나은 방법을 찾아야 함<br>
고로 Rocket은 인터페이스여야 함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Rocket</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  variant<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  thrust_kN<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> falconHeavy<span class="token operator">:</span> Rocket <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'Falcon Heavy'</span><span class="token punctuation">,</span>
  variant<span class="token operator">:</span> <span class="token string">'v1'</span><span class="token punctuation">,</span>
  thrust_kN<span class="token operator">:</span> <span class="token number">15_200</span>
<span class="token punctuation">}</span>
</code></pre></div>thrust_kN은 number 타입이고 TS는 모든 필수 필드가 존재하는지 확인하므로<br>
TS에서 제공하는 언어 서비스를 모두 사용할 수 있음(자동완성, 정의로 이동, 이름 바꾸기 등)</li> <li>런타임 떄까지 객체의 속성을 알 수 없을 경우(동적 데이터)에만 인덱스 시그니처 사용을 권장함<br>
예를 들어 CSV 파일처럼 헤더 행에 열 이름이 있고,<br>
데이터 행을 열 이름과 값으로 매핑하는 객체로 나타내고 싶은 경우<br>
일반적인 상황에서 열 이름이 무엇인지 미리 알 방법이 없음. 이럴 때 인덱스 시그니처를 사용함<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">//열 이름을 모를 경우</span>
<span class="token keyword">function</span> <span class="token function">parseCSV</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>columnName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> lines <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>header<span class="token punctuation">,</span> <span class="token operator">...</span>rows<span class="token punctuation">]</span> <span class="token operator">=</span> lines<span class="token punctuation">;</span>
    <span class="token keyword">const</span> headerColumns <span class="token operator">=</span> header<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> rows<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>rowStr <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> row<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>columnName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        rowStr<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cell<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          row<span class="token punctuation">[</span>headerColumns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> cell<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> row<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//열 이름을 알고 있는 특정 상황이라면 미리 선언해둔 타입으로 단언문 사용</span>
<span class="token keyword">interface</span> <span class="token class-name">ProductRow</span> <span class="token punctuation">{</span>
    productId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    price<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> csvData<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> products <span class="token operator">=</span> <span class="token function">parseCSV</span><span class="token punctuation">(</span>csvData<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">unknown</span> <span class="token keyword">as</span> ProductRow<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//선언해둔 열들이 런타임에 실제로 일치한다는 보장 없기 떄문에  </span>
<span class="token comment">//안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가함</span>
<span class="token keyword">function</span> <span class="token function">safeParseCSV</span> <span class="token punctuation">(</span>input<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>columnName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">parseCSV</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//이제 모든 열의 undefined 여부를 체크해야 함</span>
<span class="token comment">//체크를 추가해야하므로 작업이 번거로울 수 있음. </span>
<span class="token comment">//따라 undefined를 추가할지는 상황에 맞게 판단 필요.</span>
<span class="token keyword">const</span> rows <span class="token operator">=</span> <span class="token function">parseCSV</span><span class="token punctuation">(</span>csvData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> prices<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>product<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> row <span class="token keyword">of</span> rows<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prices<span class="token punctuation">[</span>row<span class="token punctuation">.</span>productId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>row<span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> safeRows <span class="token operator">=</span> <span class="token function">safeParseCSV</span><span class="token punctuation">(</span>csvData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> row <span class="token keyword">of</span> safeRows<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prices<span class="token punctuation">[</span>row<span class="token punctuation">.</span>productId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>row<span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//Error : undefined 형식을 인덱스 형식으로 사용할 수 없습니다.</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>연관 배열의 경우, 객체에 인덱스 시그니처를 사용하는 대신 Map 타입을 사용할 수 있음<br>
이는 프로토타입 체인과 관련된 유명한 문제를 우회함.</li> <li>어떤 타입에 가능한 필드가 제한되어 있는 경우라면 인덱스 시그니처로 모델링하지 말아야 함<br>
선택적 필드 또는 유니온 타입으로 모델링하면 됨<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Row1</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>column<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span> <span class="token comment">//너무 광범위</span>
<span class="token keyword">interface</span> <span class="token class-name">Row2</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> b<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> c<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> d<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//최선</span>
<span class="token keyword">type</span> <span class="token class-name">Row3</span> <span class="token operator">=</span> 
        <span class="token operator">|</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span> 
        <span class="token operator">|</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> b<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span> 
        <span class="token operator">|</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> b<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span> c<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span> 
        <span class="token operator">|</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> b<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span> c<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span> d<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//가장 정확하지만 사용하기 번거로움</span>
</code></pre></div></li> <li>string 타입이 너무 광범위해서 인덱스 시그니처를 사용하는데 문제가 있다면,<br>
다른 두 가지 대안이 있음
<ol><li>Record를 사용하는 방법<br>
Record는 키 타입에 유연성을 제공하는 제너릭 타입.<br>
특히 string의 부분 집합을 사용할 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Vec3D</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token string">'x'</span> <span class="token operator">|</span> <span class="token string">'y'</span> <span class="token operator">|</span> <span class="token string">'z'</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// 아래와 같음</span>
<span class="token comment">// type Vec3D = {</span>
<span class="token comment">//     x: number;</span>
<span class="token comment">//     y: number;</span>
<span class="token comment">//     z: number;</span>
<span class="token comment">// }</span>
</code></pre></div></li> <li>매핑된 타입을 사용하는 방법
매핕된 타입은 키마다 별도 타입을 사용하게 해줌<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Vec3D</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>k <span class="token keyword">in</span> <span class="token string">'x'</span> <span class="token operator">|</span> <span class="token string">'y'</span> <span class="token operator">|</span> <span class="token string">'z'</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//아래와 같음</span>
<span class="token comment">// type Vec3D = {</span>
<span class="token comment">//     x: number;</span>
<span class="token comment">//     y: number;</span>
<span class="token comment">//     z: number;</span>
<span class="token comment">// }</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">ABC</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>k <span class="token keyword">in</span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token string">'b'</span> <span class="token operator">|</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token operator">:</span> k <span class="token keyword">extends</span> <span class="token string">'b'</span> <span class="token operator">?</span> <span class="token builtin">string</span> <span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//아래와 같음</span>
<span class="token comment">// type ABC = {</span>
<span class="token comment">//     a: number;</span>
<span class="token comment">//     b: string;</span>
<span class="token comment">//     c: number;</span>
<span class="token comment">// }</span>
</code></pre></div></li></ol></li> <li>가능하다면 인덱스 시그니처보다 인터페이스, Record, 매핕된 타입 같은 정확한 타입 사용을 권장함\</li></ul> <h2 id="_16-number-인덱스-시그니처보다는-array-튜플-arraylike를-사용하기"><a href="#_16-number-인덱스-시그니처보다는-array-튜플-arraylike를-사용하기" class="header-anchor">#</a> 16. number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기</h2> <ul><li>JS는 자유도가 너무 높기로 유명한 언어이고,<br>
그 중 가장 악명 높은 것은 암시적 타입 강제와 관련된 부분.<br> <code>&quot;0&quot; == 0 //true</code><br>
다행히 이런 암시적 타입 강제와 관련된 문제는 대부분 <code>===</code>와 <code>!==</code>를 사용해 해결 가능함</li> <li>JS 객체 모델에도 이런 이상한 부분들이 있으며,<br>
이 중 일부는 TS 타입 시스템으로 모델링되기 때문에 JS 객체 모델을 이해하는 것이 중요함</li> <li>JS에서 객체란 키/값 쌍의 모음.<br>
키는 보통 문자열(ES2015 이후로는 심벌도 가능)이며, 값은 어떤 것이든 될 수 있음<br>
파이썬이나 자바에서 볼 수 있는 '해시 가능' 객체라는 표현이 JS에는 없음
<ul><li>만약 더 복잡한 객체를 키로 사용하려하면,<br>
toString 메서드가 호출되어 객체가 문자열로 변환됨</li> <li>특히 숫자는 키로 사용할 수 없음.<br>
만약 속성 이름으로 숫자를 사용한다면 JS 런타임은 문자열로 변환함</li> <li>배열은 객체이므로 키는 숫자가 아니라 문자열.<br>
Object.keys를 사용해 배열의 키를 나열하면 키가 문자열로 출력됨</li></ul></li> <li>TS는 위 같은 혼란을 바로잡기 위해 숫자 키를 허용하고, 문자열 키와 다른 것으로 인식함<br>
(Array에 대한 타입 선언은 lib.es5.d.ts에서 확인 가능)<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token punctuation">[</span>n<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>TS 타입 시스템의 다른 것들과 마찬가지로 타임 정보는 런타임에 제거되며,<br>
ECMAScript 표준이 서술하는 것처럼 문자열 키로 인식하지만<br>
타입 체크 시점에 오류를 잡을 수 있어 유용함<br>
즉, 인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 TS 코드.</li> <li>한편, Object.keys 같은 구문은 여전히 문자열로 반환됨<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> xs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>xs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//타입이 string[]</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    key<span class="token punctuation">;</span> <span class="token comment">//타입이 string</span>
    <span class="token keyword">const</span> x <span class="token operator">=</span> xs<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//타입이 number</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
string이 nubmer에 할당될 수 없기 떄문에 마지막 줄이 동작하는게 이상해 보일 수 있음  
배열을 순회하는 코드 스타일에 대한 실용적인 허용임.  
JS에서는 흔한 일이지만 배열을 순회하기에 좋은 방법은 아님  
*/</span>

<span class="token comment">//index를 신경쓰지 않는다면 for of문 사용을 권장함</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> x <span class="token keyword">of</span> xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">;</span> <span class="token comment">//타입이 nubmer</span>
<span class="token punctuation">}</span>

<span class="token comment">//만약 index의 타입이 중요하다면 </span>
<span class="token comment">//number 타입을 제공해줄 Array.prototype.forEach를 사용하면 됨</span>
xs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    i<span class="token punctuation">;</span> <span class="token comment">//타입이 number</span>
    x<span class="token punctuation">;</span> <span class="token comment">//타입이 number</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//루프 중간에 멈춰야 한다면 C 스타일인 for 루프 사용을 권장</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>xs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> x <span class="token operator">=</span> xs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>타입이 불확실하다면 for-in 루프는 대부분의 브라우저와 JS 엔진에서<br>
for-of, for 루프에 비해 몇 배나 느림</li> <li>인덱스 시그니처가 number로 표현되어 있다면 입력한 값이 number여야 하지만<br>
(for-in 루프는 확실히 제외), 실제 런타임에 사용되는 키는 string 타입.<br>
일반적으로 string 대신 number를 타입의 인덱스 시그니처로 사용할 경우는 많지 않음<br>
만약 숫자를 사용해 인덱스할 항목을 지정한다면 Array 또는 튜플 타입을 대신 사용하게 될 것.<br>
nubmer를 인덱스 타입으로 사용하면 숫자 속성이 어떤 특별한 의미를 지닌다는 오해를 불러 일으킬 수 있음</li> <li>어떤 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶다면<br>
TS에 있는 ArrayLike 타입을 사용.<br>
ArrayLike를 사용하더라도 키는 여전히 문자열.<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">checkedAccess</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>xs<span class="token operator">:</span> ArrayLike<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> i<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> xs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> xs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">배열의 끝을 지나 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">에 접근하려고 했습니다.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tupleLike<span class="token operator">:</span> ArrayLike<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string">'0'</span><span class="token operator">:</span> <span class="token string">'A'</span><span class="token punctuation">,</span>
  <span class="token string">'1'</span><span class="token operator">:</span> <span class="token string">'B'</span><span class="token punctuation">,</span>
  length<span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div></li> <li>따라 인덱스 시그니처에 number를 사용하기보다 Array, 튜플, ArrayLike 타입 사용을 권장함</li></ul> <h2 id="_17-변경-관련된-오류-방지를-위해-readonly-사용하기"><a href="#_17-변경-관련된-오류-방지를-위해-readonly-사용하기" class="header-anchor">#</a> 17. 변경 관련된 오류 방지를 위해 readonly 사용하기</h2> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">arraySum</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> num<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//Error : readonly number[] 형식에 pop 속성이 없습니다.</span>
        sum <span class="token operator">+=</span> num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>readonly를 사용하면 변경하면서 발생하는 오류를 방지할 수 있고,<br>
변경이 발생하는 코드도 쉽게 찾을 수 있음</li> <li><code>readonly number[]</code>는 타입이고, <code>number[]</code>와 구분되는 몇 가지 특징이 있음
<ul><li>배열의 요소를 읽을 수 있지만, 쓸 수는 없음</li> <li>length를 읽을 수 있지만, 바꿀 수는 없음 (배열을 변경함)</li> <li>배열을 변경하는 pop을 비롯한 다른 메서드를 호출할 수 없음</li></ul></li> <li><code>number[]</code>는 <code>readonly number[]</code>보다 기능이 많기 때문에,<br> <code>readonly number[]</code>의 서브타입이 됨.<br>
따라 변경 가능한 배열을 readonly 배열에 할당할 수 있음<br>
(그 반대는 불가능)<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">const</span> c<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">//Error: readonly number[] 타입은 readonly이므로 변경 가능한 number[] 타입에 할당될 수 없습니다.</span>
</code></pre></div>타입 단언문 없이 readonly 접근 제한자를 제거할 수 있다면<br>
readonly는 쓸모없으므로 오류 발생하는게 맞음</li> <li>매개변수를 readonly로 선언하면 아래와 같은 일이 생김
<ul><li>TS는 매개변수가 함수 내에서 변경이 일어나는지 체크함</li> <li>호출하는 쪽에서는 함수가 매개변수를 변경하지 않는다는 보장을 받게 됨</li> <li>호출하는 쪽에서 함수에 readonly 배열을 매개변수로 넣을 수도 있음</li></ul></li> <li>JS/TS에서는 명시적으로 언급하지 않는 한, 함수가 매개변수를 변경하지 않는다고 가정함<br>
그러나 이로인해 타입 체크에 문제가 일어날 수 있음.<br>
따라 명시적인 방법을 사용하는 것이 좋음</li> <li>만약 함수가 매개변수를 변경하지 않는다면, readonly로 선언해야 함<br>
더 넓은 타입으로 호출할 수 있고, 의도치 않은 변경은 방지될 것.<br>
즉, readonly 매개변수는 인터페이스를 명확하게 하며, 매개변수가 변경되는 것을 방지함</li> <li>readonly로 선언해서 생긴 단점을 굳이 찾자면<br>
매개변수가 readonly로 선언되지 않은 함수를 호출해야 할 경우도 있다는 것.<br>
만약 함수가 매개변수를 변경하지 않고도 제어가 가능하다면 readonly로 선언하면 됨.<br>
어떤 함수를 readonly로 만들면 그 함수를 호출하는 다른 함수도 모두 readonly로 만들어야하기 때문에<br>
오히려 인터페이스를 명확히 하고 타입 안정성을 높일 수 있음<br>
그러나 타 라이브러리의 함수를 호출하는 경우 타입 선언을 바꿀 수 없으므로 타입 단언문을 사용해야 함</li> <li>readonly를 사용하면 지역 변수와 관련된 모든 종류의 변경 오류를 방지할 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">parseTaggedText</span><span class="token punctuation">(</span>lines<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> currPara<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> paragraphs<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">addParagraph</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>currPara<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            paragraphs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>currPara<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//currpara의 내용이 삽입되지 않고 배열의 참조가 삽입됨</span>
          <span class="token comment">// Error: readonly string[] 형식의 인수는 string[]형식의 매개변수에 할당될 수 없습니다.</span>
            currPara<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//currpara 배열을 비움. 따라 paragraphs 요소에도 변경이 반영됨</span>
          <span class="token comment">// Error : 읽기 전용 속성이기 때문에 length에 할당할 수 없습니다.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> line <span class="token keyword">of</span> lines<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>line<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">addParagraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            currPara<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//readonly string[] 형식에 push 속성이 없습니다.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">addParagraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> paragraphs<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
위 코드는 텍스트 문자열을 넣고 실행하면 [[], [], []] 출력이 됨. 오류.
문제점은 별칭과 변경을 동시에 사용해 발생함
위의 코드는 currPara를 let으로 선언하고 변환없는 메서드를 사용함으로써 오류를 고칠 수 있음  
*/</span>
<span class="token keyword">let</span> currPara<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//...</span>
currPara <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//배열을 비움</span>
<span class="token comment">//...</span>
currPara <span class="token operator">=</span> currPara<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>line<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//concat은 원본을 수정하지 않고 새 배열을 반환함  </span>
<span class="token comment">/*
선언부를 const에서 let으로 바꾸고 readonly를 추가함으로써 한쪽의 변경 가능성을 또 다른 쪽으로 옮긴 것.
currPara 변수는 이제 가리키는 배열을 자유롭게 변경할 수 있지만, 
그 배열 자체는 변경하지 못하게 됨

여전히 남아있는 paragraphs에 대한 오류를 바로잡는 방법은 3가지가 있음

1. currPara의 복사본을 만드는 방법
paragraphs.push([...currPara]);
currPara는 readonly로 유지되지만 복사본은 원하는대로 변경이 가능하므로 오류가 사라짐

2. paragraphs(그리고 함수의 변환 타입)을 readonly string[]의 배열로 변경하는 방법
const paragraphs:(readonly string[])[] = [];
여기서 괄호가 중요한데 readonly string[][]은 
readonly 배열의 변경 가능한 배열이 아닌 변경 가능한 배열의 readonly 배열이기 때문.
이 방법은 동작하지만 해당 함수를 사용하는 사용자에게는 불편할 수 있음
이미 함수가 반환한 값에 대해 영향을 끼치는 것이 맞는 방법인지 고민해봐야 함

3. 배열의 readonly 속성을 제거하기 위해 단언문을 사용하는 방법
paragraphs.push(currPara as string[]);
바로 다음 문장에서 currPara를 새 배열에 할당하므로 매우 공격적인 단언문처럼 보이지는 않음
*/</span>
</code></pre></div></li> <li>readonly는 얕게 동작한다는 것에 유의하며 사용해야 함<br>
만약 객체의 readonly 배열이 있다면, 그 객체 자체는 readonly가 아님<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> dates<span class="token operator">:</span> <span class="token keyword">readonly</span> Date<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
dates<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//readonly Date[] 형식에 push 속성이 없습니다.</span>
dates<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">setFullYear</span><span class="token punctuation">(</span><span class="token number">2037</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div></li> <li>비슷한 경우가 readonly의 사촌격이자 객체에 사용되는 Readonly 제너릭에도 해당됨<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
    inner<span class="token operator">:</span> <span class="token punctuation">{</span>
        x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> o<span class="token operator">:</span> Readonly<span class="token operator">&lt;</span>Outer<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> inner<span class="token operator">:</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
o<span class="token punctuation">.</span>inner <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//Error: 읽기 전용 속성이기 때문에 inner에 할당할 수 없습니다.</span>
o<span class="token punctuation">.</span>inner<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div>타입 별칭을 만든 뒤 정확히 무슨일이 일어나는지 IDE에서 확인할 수 있음<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span>Outer<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// Type T = {</span>
<span class="token comment">//     readonly inner: {</span>
<span class="token comment">//        x: number; </span>
<span class="token comment">//     }</span>
<span class="token comment">// }</span>
</code></pre></div></li> <li>중요한 것은 readonly 접근제어자는 inner에 적용되는 것이지 x는 아니라는 것.<br>
현재 시점에는 deep readonly 타입이 기본으로 지원되지 않지만,<br>
제너릭을 만들면 깊은 readonly 타입 사용이 가능함<br>
그러나 제너릭은 만들기 까다롭기 때문에 라이브러리 사용을 권장함<br>
(ts-essentials의 DeepReadonly 제너릭 사용 등)</li> <li>인덱스 시그니처에도 readonly를 사용할 수 있음<br>
읽기는 허용하되 쓰기를 방지하는 효과가 있음 (객체의 속성이 변경되는 것을 방지)<div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> obj<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span>k<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//또는 Readonly&lt;[k: string]: number&gt;</span>
obj<span class="token punctuation">.</span>hi <span class="token operator">=</span> <span class="token number">45</span><span class="token punctuation">;</span> <span class="token comment">//...형식의 인덱스 시그니처는 읽기만 허용됩니다.</span>
obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>obj<span class="token punctuation">,</span> hi<span class="token operator">:</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//정상</span>
obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>obj<span class="token punctuation">,</span> bye<span class="token operator">:</span><span class="token number">34</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//정상</span>
</code></pre></div></li></ul> <h2 id="_18-매핑된-타입을-사용하여-값을-동기화하기"><a href="#_18-매핑된-타입을-사용하여-값을-동기화하기" class="header-anchor">#</a> 18. 매핑된 타입을 사용하여 값을 동기화하기</h2> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">ScatterProps</span> <span class="token punctuation">{</span>
  <span class="token comment">//The data</span>
  xs<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  ys<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">//Display</span>
  xRange<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  yRange<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  color<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  <span class="token comment">//Events</span>
  <span class="token function-variable function">onCLick</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
불필요한 작업을 피하기 위해, 필요할 때에만 차트를 다시 그리도록 최적화를 구현
(데이터나 디스플레이 속성이 변경되면 다시 그리지만, 
이벤트 핸들러가 변경되면 다시 그리지 않음)
*/</span>

<span class="token comment">/*
&lt;첫 번째 최적화 방법&gt;
만약 새로운 속성이 추가되면 shouldUpdate 함수는 값이 변경될 때마다 차트를 다시 그림
이렇게 처리하는 것을 '보수적 접근법' 또는 '실패에 닫힌 접근법'이라고 함
이 접근법을 이용하면 차트가 정확하지만 너무 자주 그려질 가능성 있음
*/</span>
<span class="token keyword">function</span> <span class="token function">shouldUpdate</span><span class="token punctuation">(</span>oldProps<span class="token operator">:</span> ScatterProps<span class="token punctuation">,</span> newProps<span class="token operator">:</span> ScatterProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> k<span class="token operator">:</span> <span class="token keyword">keyof</span> ScatterProps<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token keyword">in</span> oldProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldProps<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!==</span> newProps<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">!==</span> <span class="token string">'onCLick'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
&lt;두 번째 최적화 방법&gt;
이 코드는 차트를 불필요하게 다시 그리는 단점을 해결함
하지만 실제로 차트를 다시 그려야 할 경우 누락되는 일이 생길 수 있음
이 방법은 '우선 망치치 말 것'이라는 원칙을 어기기 때문에 일반적으로 사용하는 방법은 아님
*/</span>
<span class="token keyword">function</span> <span class="token function">shouldUpdate</span><span class="token punctuation">(</span>oldProps<span class="token operator">:</span> ScatterProps<span class="token punctuation">,</span> newProps<span class="token operator">:</span> ScatterProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
          oldProps<span class="token punctuation">.</span>xs <span class="token operator">!==</span> newProps<span class="token punctuation">.</span>xs <span class="token operator">||</span>
          oldProps<span class="token punctuation">.</span>ys <span class="token operator">!==</span> newProps<span class="token punctuation">.</span>ys <span class="token operator">||</span>
          oldProps<span class="token punctuation">.</span>xRange <span class="token operator">!==</span> newProps<span class="token punctuation">.</span>xRange <span class="token operator">||</span>
          oldProps<span class="token punctuation">.</span>yRange <span class="token operator">!==</span> newProps<span class="token punctuation">.</span>yRange <span class="token operator">||</span>
          oldProps<span class="token punctuation">.</span>color <span class="token operator">!==</span> newProps<span class="token punctuation">.</span>color
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
위 두가지 최적화 모두 이상적이지 않음
새로운 속성이 추가될 때 직접 shouldUpdate를 고치도록 하는게 나음
(주석으로 속성을 추가하면 sholudUpdate를 고치라고 적던지 등)
하지만 이 방법 또한 최선이 아니며, 
아래 코드처럼 타입 체커가 대신할 수 있게 하는 것이 좋음
핵심은 매핑된 타입과 객체를 사용하는 것

[k in keyof ScatterProps]는 타입체커에게 REQUIRES_UPDATE가 ScatterProps와 
동일한 속성을 가져야 함을 알려줌. 후에 ScatterProps에 새로운 속성을 추가하는 경우
REQUIRES_UPDATE에 정의에 오류가 발생함
//Error: '새로운 속성' 속성이 타입에 없습니다.

이런 방식은 오류를 정확히 잡아냄.
속성을 삭제하거나 수정해도 비슷한 오류가 발생함
*/</span>
<span class="token keyword">const</span> <span class="token constant">REQUIRES_UPDATE</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>k <span class="token keyword">in</span> <span class="token keyword">keyof</span> ScatterProps<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  xs<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  ys<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  xRange<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  yRange<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  color<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  onCLick<span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/*
여기서 boolean 값을 가진 객체를 사용했다는 점이 중요함
만약 배열을 사용했다면 아래 같은 코드가 됨. 
const REQUIRES_UPDATE: (keyof ScatterProps)[] = ['xs', 'ys', ...];
여기서 실패에 열린 방법을 선택할지 닫힌 방법을 선택해야 할지 정해야 함
*/</span>

<span class="token keyword">function</span> <span class="token function">shouldUpdate</span><span class="token punctuation">(</span>oldProps<span class="token operator">:</span> ScatterProps<span class="token punctuation">,</span> newProps<span class="token operator">:</span> ScatterProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> k<span class="token operator">:</span> <span class="token keyword">keyof</span> ScatterProps<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token keyword">in</span> oldProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldProps<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!==</span> newProps<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token constant">REQUIRES_UPDATE</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>매핑된 타입은 한 객체가 또 다른 객체와 정확히 같은 속성을 가지게 할 때 이상적임<br>
매핑된 타입을 사용해 타입스크립트가 코드에 제약을 강제하도록 할 수 있음</li> <li>매핑된 타입을 사용해 관련된 값과 타입을 동기화하도록 함</li> <li>인터페이스에 새로운 속성을 추가할 때, 선택을 강제하도록 매핑된 타입을 고려해야 함</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/TIL/assets/js/app.2d66ab00.js" defer></script><script src="/TIL/assets/js/2.5e3b8e3c.js" defer></script><script src="/TIL/assets/js/124.f373a65b.js" defer></script>
  </body>
</html>
