---
title : 함수와 프로토타입 체이닝
date : 2021.09
---

# 함수와 프로토타입 체이닝
2021.09


## 함수 정의
자바스크립트에서 함수 생성 방법은 3가지.  
3가지 방법 모두 같은 함수를 생성하지만 함수 동작에 미묘한 차이가 있음
* 함수 선언문
* 함수 표현식
* Function() 생성자 함수

### 함수 리터럴
자바스크립트에서는 함수도 일반객체처럼 값으로 취급.  
때문에 객체 리터럴 방식으로 객체 생성이 가능한 것처럼 함수 리터럴 이용해 함수 생성 가능   
(함수 선언문이나 함수 표현식 모두 함수 리터럴 방식으로 함수 생성)
```js
//함수 리터럴을 통한 add() 함수 정의
function add(x, y) { 
    //함수 리터럴은 function 키워드로 시작하며,
    //함수명은 함수 내부 코드에서 자신을 재귀적으로 호출하거나 자바스크립트 디버거가 함수를 구분하는 
    //식별자로 사용됨. 함수명은 선택사항
    return x + y;
}
```

### 함수 선언문 방식으로 함수 생성
함수 리터럴 형태와 같으며, 함수 선언문 방식으로 함수를 생성할 경우 반드시 함수명이 정의되어야 함  
```js
function add(x,y) {
    return x + y;
}
console.log(add(3,4)); //7
//함수 선언문 형식으로 정의된 함수는 자바스크립트 엔진에 의해 아래와 같은 함수 표현식 형태로 변경됨
//var add = function add(x,y) {}
//함수 이름과 함수변수의 이름이 add로 같으므로 함수 이름으로 함수가 호출되는 것처럼 보임
//실제로는 add함수 변수로 함수 외부에서 호출 가능한 것
```

### 함수 표현식 방식으로 함수 생성
함수도 하나의 값처럼 취급되므로 숫자나 문자열처럼 변수에 할당 가능  

이런 방식으로 함수 리터럴로 하나의 함수를 만든 뒤,  
생성된 함수를 변수에 할당해 함수를 생성하는 것을 함수 표현식이라고 함  
(함수 표현식에서 함수명은 선택사항이며 보통 사용하지 않음)  

익명 함수 : 이름이 없는 함수 형태  
```js
var add = function(x, y){ //익명함수
    //add변수는 함수를 참조하는 변수이지 함수이름이 아님
    return x + y;
};
var plus = add; //add변수는 함수의 참조값을 가지고 있으므로 다른 변수에도 그 값을 할당할 수 있음
console.log(add(3,4)); //7
console.log(plus(3,4)); //7 : add함수와 plus함수는 동일한 익명함수를 참조
```

기명 함수 표현식 : 함수 이름이 포함된 함수 표현식  
함수 표현식에서 사용된 함수 이름은 외부 코드에서 접근 불가능하기 떄문에  
기명 함수 표현식을 사용할 경우 함수 이름으로 함수 외부에서 해당 함수 호출 시 정의되어있지 않다는 에러 남    
```js
var add = function sum(x, y) {
    return x + y;
};
console.log(add(3,4)); //7
console.log(sum(3,4)); //Error
```

함수 내부 코드에서 재귀적 호출
```js
var factorialVar = function factorial(n) {
    if(n <= 1) {
        return 1;
    }
    return n * factorial(n-1); //함수 내부에서 이뤄지는 재귀 호출은 함수명으로 처리됨
};
console.log(factorialVar(3));//6
console.log(factorial(3));//Error (함수 외부에서 함수명으로 접근 불가능)
```

### function statement와 function expression에서의 세미콜론
일반적으로 자바스크립트 코드 작성 시 함수 선언문 방식으로 선언된 함수는 끝에 세미콜론을 붙이지 않지만,  
함수 표현식 방식의 경우는 세미콜론을 붙이는 것을 권장  

자바스크립트 인터프리터가 자동으로 세미콜론을 붙여주기 때문에 자바스크립트에서는  
세미콜론 사용을 강제하지 않지만 심각한 디버깅 상황에 직면할 수 있으므로 세미콜론 사용해야 함  
```js
var func = function(){
    return 42;
}//세미콜론 사용하지 않음
(function(){
    console.log('functino called');
})();
//number is not a function 에러 나타남
//func() 함수 정의에서 세미콜론을 사용하지 않아 중괄호 만으로 함수가 끝났다고 판단하지 못하기 때문
//때문에 ()괄호에 둘러쌓인 즉시 실행함수를 func() 함수의 호출 연산으로 생각해 func()함수를 호출해버림
//func()함수가 호출되면 42가 반환되고 즉시 실행함수를 실행하려고 남겨둔()괄호로 인해 
//42() 형태로 또 다시 함수를 호출하려고 시도함. 때문에 에러 발생
```

### Function() 생성자 함수를 통해 함수 생성
자바스크립트의 함수는 Function()이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있음  
함수 선언문, 함수 표현식 방식은 함수 리터럴 방식으로 함수를 생성하지만 내부적으로는  
Function() 생성자 함수로 함수가 생성된다고 볼 수 있음   
일반적으로 Function() 생성자 함수 사용 함수 생성 방법은 자주 사용되지 않음  
```js
//Function() 생성자 함수로 함수 생성
new Function(arg1, arg2, ...argN, functionBody)
//arg1, arg2, ...argN : 함수의 매개변수
//functionBody : 함수 호출 시 실행될 코드를 포함한 문자열

var add = new Function('x', 'y', 'return x + y');
console.log(add(3,4)); //7
```

### 함수 호이스팅
위의 함수 생성방법 3가지는 서로 같은 기능의 함수를 생성하지만 동작 방식에 약간의 차이가 있음  
그 중 하나가 **함수 호이스팅**  

함수 선언문 형태로 정의된 함수는 호이스팅이 일어나 함수의 유효범위가 코드의 맨 처음부터 시작됨  
이런 함수 호이스팅은 함수 사용 전 반드시 선언해야한다는 규칙을 무시하므로 코드의 구조가 엉성해짐
함수 호이스팅의 발생 원인은 자바스크립트의 변수 생성과 초기화의 작업이 분리되서 진행되기 때문  

자바스크립트 Guru로 알려진 더글라스 크락포드는 함수 호이스팅 때문에  
함수 생성에 있어 함수 표현식만을 사용할 것을 권장함   
```js
//함수 선언문 형태
add(2,3); //5 : 함수 호이스팅 일어남
function add(x,y) {
    return x+y;
}
add(2,3); //5

//함수 표현식 형태
add2(2,3); //Error : 함수 호이스팅 일어나지 않음
var add2 = function(x,y){
    return x+y;
};
add2(2,3); //5
```


## 함수 객체 : 함수도 객체

### 자바스크립트에서는 함수도 객체
자바스크립트에서는 함수도 객체  
함수의 기본 기능인 코드 실행 뿐 아니라, 함수 자체가 일반 객체처럼 프로퍼티들을 가질 수 있음  
```js
function add(x, y) { 
    //add()함수 생성 시 함수 코드는 함수 객체의 [[Code]] 내부 프로퍼티에 자동으로 저장됨
    return x + y;
}
//add()함수 객체에 result, status 프로퍼티 추가
add.result = add(3,2); //add()함수에 일반 객체처럼 프로퍼티를 동적으로 생성 가능
add.status = "OK";

console.log(add.result); //5 : 함수 객체의 프로퍼티도 일반 객체의 점근 방식처럼 접근 가능
console.log(add.status); //"OK"
```
add 함수 객체  
* [[Code]] = `return x+y;`
* result = 5
* status = "OK"

### 자바스크립트에서 함수는 값으로 취급됨
함수도 일반 객체처럼 취급될 수 있기 떄문에 자바스크립트 함수는 아래와 같은 동작 가능   
* 리터럴에 의해 생성
* 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
* 함수의 인자로 전달 가능
* 함수의 리턴값으로 리턴 가능
* 동적으로 프로퍼티를 생성 및 할당 가능

이런 특징이 있어 자바스크립트에서는 함수를 **일급 객체**라고 부름  
일급 객체 : 컴퓨터 프로그래밍 언어 분야에서 쓰이는 용어. 앞에서 나열한 기능이 모두 가능한 객체를 뜻함  
자바스크립트 함수가 가지는 일급 객체의 특성으로 함수형 프로그래밍 가능  

#### 변수나 프로퍼티의 값으로 할당
숫자나 문자열처럼 함수도 변수나 배열의 원소, 프로퍼티의 값으로 할당될 수 있음
```js
//변수에 함수 할당
var foo = 100;
var bar = function(){return 100;}
console.log(bar()); //100

//프로퍼티에 함수 할당
var obj = {};
obj.baz = function(){return 200;}
console.log(obj.baz()); //200
```

#### 함수 인자로 전달
함수는 다른 함수의 인자로도 전달 가능
```js
var foo = function(func){
    func();
};
foo(function(){
    console.log('wow!')
}); //"wow!"
```

#### 리턴값으로 활용
함수자체가 값으로 취급되기 때문에 함수는 다른 함수의 리턴값으로도 활용 가능
```js
var foo = function(){
    return function(){
        consoel.log('wow');
    };
};
var bar = foo(); //foo()함수 호출 시 리턴값으로 전달되는 함수가 bar에 저장
bar(); //"wow" : ()함수 호출 연산자 사용해 리턴된 함수 실행 가능
```

### 함수 객체의 기본 프로퍼티
함수는 객체이므로 함수 역시 일반적인 객체의 기능에 추가로 호출됐을 때 정의된 코드를 실행하는 기능을 가지고 있음  
또한, 일반 객체와는 다르게 추가로 함수 객체만의 표준 프로퍼티가 정의되어 있음  
```js
function add(x, y) {
    return x + y;
}
console.dir(add); 
//함수에는 arguments, caller, length 등과 같은 다양한 프로퍼티가 기본적으로 생성되어 있음  
//(함수 생성시 포함되는 표준 프로퍼티)
```
함수의 표준 프로퍼티 중 length와 prototype 프로퍼티는 ECMA5 스크립트 명세서에서 정의된 함수 필수 프로퍼티.  
(자세한 내용은 뒤에)
name, caller, agruments, __proto__ 프로퍼티들은 ECMA 표준은 아님  
* name 프로퍼티 : 함수의 이름을 나타냄. 익명 함수일 경우 빈 문자열
* caller 프로퍼티 : 자신을 호출한 함수를 나타냄
* arguments 프로퍼티 : 함수 호출 시 전달된 인자값을 나타냄  
  (ECMA 표준에서는 arguments 프로퍼티와 같은 이름으로 arguments 객체를 정의함.  
  arguments 객체는 함수 호출 시 호출된 함수 내부로 인자값과 함께 전달되며,  
  arguments 프로퍼티와 유사하게 함수 호출 시 전달 인자값의 정보를 제공해 줌)

#### __proto__ 프로퍼티
모든 자바스크립트 객체는 자신의 프로토타입을 가리키는 [[Prototype]]라는 내부 프로퍼티를 가지고 있음  
(크롬 브라우저에서는 [[Prototype]]이라는 내부 프로퍼티가 __proto__ 프로퍼티로 구현되어 있음. [[Prototype]]와 __proto__는 같은 개념)  
함수 역시 객체이므로 __proto__ 프로퍼티를 가지고 있고 이를 통해 자신의 부모 역할을 하는 프로토타입 객체를 가리킴   
함수 객체의 부모 역할을 하는 프로토타입 객체는 Function.prototype 객체이며 이것 역시 함수 객체  
(크롬 브라우저에서는 Function Prototype 객체를 Empty() 함수라고 명함)  
Function Prototype 객체도 함수 객체이므로 name, caller, arguments 등과 같은 함수 객체의 프로퍼티가 존재  

