---
title : 함수 정의  
data : 2022.04.22
---

# 함수 정의

함수 생성 방식은 3가지가 있고, 모두 같은 함수를 생성하지만 방식에 따라 함수 동작이 미묘하게 차이 남  
- 함수 선언문  
- 함수 표현식
- Function() 생성자 함수


## 1. 함수 리터럴

JS는 함수도 일반 객체처럼 값으로 취급.  
때문에 객체 리터럴 방식으로 일반 객체를 생성 가능한 것처럼, JS에서는 **함수 리터럴**을 이용해 함수 생성 가능.  
함수 선언문이나 함수 표현식 방법 모두 함수 리터럴 방식으로 함수를 생성함  

```jsx
function add (x, y) {
	return x + y;
}
```

1. function : JS 함수 리터럴은 function 키워드로 시작
2. 함수명 : 함수명은 함수 내부 코드에서 자신을 재귀적으로 호출하거나 자바스크립트 디버거가 함수를 구분하는  
   식별자로 사용. 함수명은 선택 사항이며 함수명이 없는 함수를 익명함수라고 함
3. 매개변수 리스트 : 매개변수는 타입을 기술하지 X
4. 함수 몸체 : 실체 함수 호출 시 실행되는 코드 부분


## 2. 함수 선언문
- 함수 리터럴 형태와 같음
- 함수 선언문 방식으로 정의된 함수는 **함수명 정의가 필수**

```js
function add (x, y) {
	return x + y;
}
console.log(add(3,4)); //7
```

함수 이름은 외부 코드에서 접근이 불가능한데 함수 선언문 방식으로 정의한 함수는  
어떻게 함수 이름으로 함수 외부에서 호출이 가능할까?
```js
var add = function add (x, y) {
	return x + y;
}
```
1. 함수 선언문으로 정의된 함수는 자바스크립트 엔진에서 위와 같은 함수 표현식 형태로 변경되기 때문
2. 함수 이름과 함수 변수의 이름이 같으므로 함수 이름으로 함수가 호출되는 것처럼 보이지만  
   실제로는 함수 변수로 함수 외부에서 호출이 가능


## 3. 함수 표현식
- 함수도 하나의 값처럼 취급되므로 숫자나 문자열 처럼 변수에 할당 가능  
  함수 리터럴로 하나의 함수를 만들고 생성된 함수를 변수에 할당해 함수 생성하는 방식  
  (함수 리터럴로 함수 생성 -> 변수에 저장)  
- 함수 선언문 방식과 거의 유사하지만 함수 이름이 선택 사항이며 보통 사용하지 않는 차이점이 있음
- 함수 표현식에서 사용된 함수 이름은 외부 코드에서 접근 불가  
  (함수 이름은 정의된 함수 내부에서 해당 함수를 재귀적으로 호출하거나 디버거 등에서 함수 구분 시 사용됨)
```js
//익명 함수 표현식
var add = function(x, y) { 
	return x + y;
};
var plus = add;
console.log(add(3,4)); //7
console.log(plus(5,6)); //11
```
1. add 변수는 함수 리터럴로 생성한 함수를 참조하는 변수(함수가 할당된 변수 = 함수 변수)이지  
   함수 선언문의 add처럼 함수 이름이 아님
2. 함수 변수 add는 함수의 참조값을 가지므로 다른 변수 plus에도 그 값을 그대로 할당 가능  
   (add와 plus 함수 변수는 동일한 익명 함수를 참조)
3. 함수 표현식으로 생성된 함수를 호출하려면 함수 변수를 사용해야 함
4. plus 또한 add 함수 변수와 같은 함수를 참조하는 함수변수이므로 같은 형태로 함수 호출

<br>

이름이 없는 익명 함수를 변수에 할당해서 사용하는 것을 익명 함수 표현식이라고 하며,  
함수 이름이 포함된 함수 표현식을 기명 함수 표현식이라고 함.
```js
 // 기명 함수 표현식
var add = function sum (x,y) {
	return x + y;
};
console.log(add(3,4)); //7
console.log(sum(3,4)); //Uncaught ReferenceError : sum is not defined


var factorialVar = function factorial(n) {
	if(n <= 1) {
		return 1;
	}
	return n * factorial(n-1);
};
console.log(factorialVar(3)) //6
console.log(factorial(3)); //Uncaught ReferenceError : factorial is not defined
```
1. sum() 함수를 정의하고 add 변수에 할당. 함수 표현식에서 사용된 함수명은 외부 코드에서 접근 불가
2. 함수 외부에서는 함수 변수(factorialVar)로 함수를 호출 가능하며,  
   함수 내부에서 이뤄지는 재귀 호출은 함수명(factorial)으로 처리 

<br>

### function statement와 function expression에서의 세미콜론
일반적으로 JS 코드 작성 시 함수 선언문 방식으로 선언된 함수의 경우 함수 끝에 세미콜론(;)을 붙이지 않지만,  
함수 표현식 방식의 경우는 세미콜론을 붙이는 것을 권장함  

자바스크립트는 인터프리터가 자동으로 세미콜론을 삽입시켜 주기 때문에 세미콜론 사용을 강제하지는 않지만   
세미콜론 사용을 신경 쓰지 않으면 심각한 디버깅 상황에 직면할 수 있음   
```js
var func = function(){
    return 42;
} //세미콜론 사용하지 않음
(function(){
    console.log('function called');
})();
```
위의 코드 의도는 42를 리턴하는 func() 함수를 정의하고, 즉시 실행 함수 형식으로 'function called'을 출력하는 것.
하지만 이 코드는 실제로 func()함수를 호출 시 'number is not a function'이라는 에러 발생함  

이유는 자바스크립트 파서가 func()의 함수 정의에서 세미콜론을 사용하지 않아 return 42; 문장을 지나  
func() 함수 정의 끝에 있는 중괄호 만으로 func() 함수가 끝났다고 판단하지 않기 때문

1. func() 함수 정의에서 세미콜론을 사용하지 않았기 때문에 자바스크립트 파서는  
   func() 함수 정의 끝에 있는 중괄호 만으로 함수가 끝났다고 판단하지 않음
2. 자바스크립트 파서는 괄호에 둘러싸여 정의된 즉시 실행함수를 보고 이를  
   func() 함수 호출 연산으로 생각해 func() 함수를 호출해버림
3. func() 함수가 호출되면 42가 반환됨
4. 즉시 실행 함수를 실행하려고 남겨둔 마지막() 괄호가 있으므로 42(); 형태로 또 다시 함수를 호출하려 시도
5. 42는 숫자이지 함수가 아니므로 에러 발생

위와 같은 문제가 발생할 수 있어 자바스크립트 가이드에서는 함수 표현식 방식에서 세미콜론 사용을 강력히 권고함


## 4. Function() 생성자 함수
자바스크립트의 함수는 Function() 이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있음  
함수 선언문이나 함수 표현식 방식도 Function() 생성자 함수가 아닌 함수 리터럴 방식으로 함수를 생성하지만,  
결국엔 이 또한 내부적으로는 Function() 생성자 함수로 함수가 생성된다고 볼 수 있음  

일반적으로 Function() 생성자 함수를 사용한 함수 생성 방법은 자주 사용되지는 않음

```js
var add = new Function('x', 'y', 'return x+y');
console.log(add(3,4)); //7
```


## 5. 함수 호이스팅
함수 생성하는 3가지 방식은 모두 같은 기능의 함수를 생성하지만 동작 방식이 약간 차이가 있는데  
그 중 하나가 **함수 호이스팅**.  

자바스크립트 Guru로 알려진 더글라스 크락포드는 함수 생성에 있어서 함수 표현식만을 사용할 것을 권하고 있음  
그 이유 중 하나가 함수 호이스팅 때문  

- 함수 선언문 방식과 함수 호이스팅
    ```js
    add(2,3); //5
    
    function add(x, y) {
        return x + y;
    }
    add(3,4); //7
    ```
  가장 위의 코드는 실행 시점에 함수가 정의되지 않았음에도 밑에 정의된 함수 호출이 가능함  
  함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다는 것을 알 수 있음  
  이것을 함수 호이스팅이라고 함  

  이런 함수 호이스팅이 발생하는 원인은 자바스크립트의 변수 생성과 초기화의 작업이 분리되서 진행되기 때문  
  더글리스 크락포드는 이런 함수 호이스팅은 함수를 사용하기 전 반드시 선언해야 하는 규칙을 무시하므로  
  코드의 구조를 엉성하게 만들 수 있다고 지적하며 함수 표현식 사용을 권장하고 있음

- 함수 표현식 방식과 함수 호이스팅
    ```js
    add(2,3); //uncaught type error
    
    var add = function (x, y) {
        return x + y;
    };
    add(3,4); //7
    ```
  함수 표현식 형태로 함수를 정의하면 호이스팅이 일어나지 않음. 따라 함수가 생성된 후에 호출 가능   
