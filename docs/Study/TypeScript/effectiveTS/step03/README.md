---
title : 타입 추론   
date : 2023.01.22
---

# 타입 추론
* 타입스크립트는 타입 추론을 적극적으로 수행함
* 타입 추론은 수동으로 명시해야 하는 타입 구문의 수를 효울적으로 줄여주기 때문에,  
  코드의 전체적인 안정성이 향상됨
* 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문(중요한 부분에는 사용)을 사용함

## 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기
### 불필요한 타입 선언
* 타입스크립트의 많은 타입 구문은 사실 불필요함.  
  코드의 모든 변수에 타입을 선언하는 것은 비생산적.
    ```ts
    let x1:number = 12;
    let x2 = 12; //이렇게만 작성해도 충분함
    ```
* 타입스크립트가 타입을 추론 가능하다면 타입 구문을 작성하지 않는 게 좋음  
  (해당 타입이 추론되는지 알고 싶다면 편집기를 사용해 확인 가능)  
* 타입스크립트는 복잡한 객체도 추론 가능함  
  따라 값에 추가로 타입을 작성하는 것은 거추장스러울 뿐임
* 배열의 경우도 타입스크립트는 입력받아 연산하는 함수가 어떤 타입을 반환하는지 정확히 알고 있음  
* 타입스크립트는 예상하는 것보다 더 정확하게 추론하기도 함
    ```ts
    const axis1: string = 'x'; //타입은 string
    const axis2 = 'y'; //타입은 'y'
    ```
* 타입이 추론되면 리팩터링 역시 용이해짐  
* 비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 함  
  따라 명시적 타입 구문을 넣을 필요 없음
* 이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만,  
  함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않음  
  타입 구문을 생략해 방해되는 것들을 최소화하고 구현 로직에 집중할 수 있게 작성하는게 좋음
* 함수 매개변수에 기본 값이 있는 경우 타입 구문 생략해도 됨  
* 보통 타입 정보가 있는 라이브러리에서 콜백 함수의 매개변수 타입은 자동으로 추론됨

### 타입 선언이 필요한 경우
* 정보가 부족해서 타입스크립트가 스스로 타입을 판단하기 어려운 상황도 일부 있음  
  그럴 때는 명시적 타입 구문이 필요함  
  어떤 언어들은 매개변수의 최종 사용처까지 참고해 타입을 추론하지만,  
  타입스크립트는 최종 사용처까지 고려하지 않음  
  타입스크립트의 타입은 일반적으로 처음 등장할 때 결정됨  
* 타입이 추론될 수 있음에도 여전히 타입을 명시하고 싶은 몇 가지 상황이 있음  
  * 객체 리터럴 정의 시 타입 명시           
    객체 리터럴을 정의할 때 타입을 명시하면 잉여 속성 체크가 동작함   
    잉여 속성 체크는 특히 선택적 속성이 있는 타입의 오타 같은 오류를 잡는데 효과적임    
    그리고 변수가 사용되는 순간이 아닌 할당하는 시점에 오류가 표시되도록 해줌   
    만약 타입 구문을 제거한다면 잉여 속성 체크가 동작하지 않고,   
    객체를 선언한 곳이 아니라 사용되는 곳에서 타입 오류가 발생함.  
    타입 구문을 제대로 명시한다면 실제로 실수가 발생한 부분에 오류를 표시해줌
  * 함수의 반환에 타입을 명시       
    * 타입 추론이 가능하더라도 구현상의 오류가 함수를 호출한 곳까지  
      영향을 미치지 않도록 하기 위해 타입 구문을 명시하는 게 좋음   
      의도된 반환 타입을 명시하면 실수가 발생한 정확한 위치에 오류가 표시됨  
      따라 구현상의 오류가 사용자 코드의 오류로 표시되지 않음  
    * 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있음    
      반환 타입을 명시하려면 구현하기 전 입력과 출력 타입에 대해 알아야함  
      추후 코드가 변경되어도 보통 해당 함수의 시그니처는 쉽게 변경되지 않음  
      따라 미리 타입을 명시하는 방법은 TDD(테스트 주도 개발)과 비슷함  
      전체 타입 시그니처를 먼저 작성하면 구현에 맞춰   
      주먹구구식으로 시그니처가 작성되는 것을 방지하고 제대로 원하는 모양을 얻게 됨  
    * 반환 타입을 명시하면 명명된 타입을 사용할 수 있음  
      반환 값을 별도의 타입으로 정의하면 타입에 대한 주석을 작성할 수 있어 더욱 자세한 설명이 가능하며,  
      더욱 직관적이 표현이 됨. 추론된 반환 타입이 복잡해질수록 명명된 타입을 제공하는 이점은 커짐  
* linter를 사용한다면 eslint 규칙 중 no-inferrable-types을 사용해  
  작성된 모든 타입 구문이 정말 필요한지 확인 가능함  


## 20. 다른 타입에는 다른 변수 사용하기
* 자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 됨  
  반면 타입스크립트에서는 오류가 발생함  
  변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않기 때문  
  (타입을 바꿀 수 있도록 범위를 좁히거나 타입 지정 방법이 있지만 이 방법은 어디까지나 예외)  
* 유니온 타입으로 변수의 타입을 확장한다면 더 많은 문제가 생길 수 있음  
  해당 변수를 사용할 때마다 값이 어떤 타입인지 확인해야 하기 때문에 간단한 타입에 비해 다루기 더 어려움  
  따라, 가장 좋은 방법은 별도의 변수를 도입하는 것.  
* 변수를 무분별하게 재사용하면 타입 체커와 사람 모두에게 혼란을 줄 수 있으므로  
  서로 관련 없는 변수는 별도의 변수를 만들어 사용하는 것이 좋음

### 다른 타입에는 별도의 변수를 사용하는 것이 바람직한 이유
* 서로 관련이 없는 두 개의 값을 분리함
* 변수명을 더 구체적으로 지을 수 있음
* 타입 추론을 향상시키며, 타입 구문이 불필요해짐
* 타입이 좀 더 간결해짐
* let 대신 const로 변수를 선언하게 됨    
  const로 변수 선언 시 코드가 더 간결해지고 타입 체커가 타입을 추론하기도 좋음  

<br>

따라 타입이 바뀌는 변수는 되도록 피해야 하며,  
목적이 다른 곳에는 별도의 변수명을 사용해야 함  

### 재사용되는 변수와 가려지는 변수
지금까지 이야기한 재사용되는 변수와 가려지는 변수를 혼동해서는 안됨  
```ts
const id = '12-34-56';
fetchProduct(id);

{
    const id = 123456; //정상
    fetchProductBySeriaNumber(id); //정상
}
```
* 여기서 두 id는 이름은 같지만 서로 아무런 관계가 없음    
  그러므로 각기 다른 타입으로 사용되어도 문제 없음
* 하지만 동일한 변수명에 타입이 다르다면,   
  타입스크립트 코드는 잘 동작하지 몰라도 사람에게 혼란을 줄 수 있음  
* 고로 목적이 다른 곳에는 별도의 변수명을 사용해야 함  
* 많은 개발팀이 린터 규칙을 통해 '가려지는' 변수를 사용하지 못하도록 하고 있음


## 21. 타입 넓히기
