<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>25장. 클래스 | sso214&#39;s TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Today I Learned">
    
    <link rel="preload" href="/TIL/assets/css/0.styles.dd5ac3b9.css" as="style"><link rel="preload" href="/TIL/assets/js/app.e4018421.js" as="script"><link rel="preload" href="/TIL/assets/js/2.f771dbe5.js" as="script"><link rel="preload" href="/TIL/assets/js/68.c297e89c.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.1bceb649.js"><link rel="prefetch" href="/TIL/assets/js/100.7124ec76.js"><link rel="prefetch" href="/TIL/assets/js/101.ca3464fc.js"><link rel="prefetch" href="/TIL/assets/js/102.b6ef9ef4.js"><link rel="prefetch" href="/TIL/assets/js/103.813007f4.js"><link rel="prefetch" href="/TIL/assets/js/104.f532853b.js"><link rel="prefetch" href="/TIL/assets/js/105.42492ae1.js"><link rel="prefetch" href="/TIL/assets/js/106.6e42cf20.js"><link rel="prefetch" href="/TIL/assets/js/107.ab973420.js"><link rel="prefetch" href="/TIL/assets/js/108.7bf9e566.js"><link rel="prefetch" href="/TIL/assets/js/109.1d703e0d.js"><link rel="prefetch" href="/TIL/assets/js/11.dd318727.js"><link rel="prefetch" href="/TIL/assets/js/110.d94ba33e.js"><link rel="prefetch" href="/TIL/assets/js/111.c0cc84e0.js"><link rel="prefetch" href="/TIL/assets/js/112.98d015bb.js"><link rel="prefetch" href="/TIL/assets/js/113.4a69c5dc.js"><link rel="prefetch" href="/TIL/assets/js/114.5508c150.js"><link rel="prefetch" href="/TIL/assets/js/115.d4b7ca4e.js"><link rel="prefetch" href="/TIL/assets/js/116.ac87f6c1.js"><link rel="prefetch" href="/TIL/assets/js/117.e96fceea.js"><link rel="prefetch" href="/TIL/assets/js/118.af051b9d.js"><link rel="prefetch" href="/TIL/assets/js/119.4f074945.js"><link rel="prefetch" href="/TIL/assets/js/12.35d2773d.js"><link rel="prefetch" href="/TIL/assets/js/120.ab537aee.js"><link rel="prefetch" href="/TIL/assets/js/121.02cba240.js"><link rel="prefetch" href="/TIL/assets/js/122.8f088101.js"><link rel="prefetch" href="/TIL/assets/js/123.d8b82fe2.js"><link rel="prefetch" href="/TIL/assets/js/124.0eadf28a.js"><link rel="prefetch" href="/TIL/assets/js/125.bbddeb58.js"><link rel="prefetch" href="/TIL/assets/js/126.9cd431e1.js"><link rel="prefetch" href="/TIL/assets/js/127.3302a550.js"><link rel="prefetch" href="/TIL/assets/js/128.ca7db561.js"><link rel="prefetch" href="/TIL/assets/js/129.d5513380.js"><link rel="prefetch" href="/TIL/assets/js/13.cc52b034.js"><link rel="prefetch" href="/TIL/assets/js/130.66f1e0e2.js"><link rel="prefetch" href="/TIL/assets/js/131.a55edbb8.js"><link rel="prefetch" href="/TIL/assets/js/132.4ed3cf0f.js"><link rel="prefetch" href="/TIL/assets/js/133.d41105f3.js"><link rel="prefetch" href="/TIL/assets/js/134.645f05af.js"><link rel="prefetch" href="/TIL/assets/js/135.17f65bea.js"><link rel="prefetch" href="/TIL/assets/js/136.184ee26c.js"><link rel="prefetch" href="/TIL/assets/js/137.3dca059e.js"><link rel="prefetch" href="/TIL/assets/js/138.7682a8b1.js"><link rel="prefetch" href="/TIL/assets/js/139.5b18161e.js"><link rel="prefetch" href="/TIL/assets/js/14.8cfc8fbe.js"><link rel="prefetch" href="/TIL/assets/js/140.ba679f1b.js"><link rel="prefetch" href="/TIL/assets/js/141.77fbf300.js"><link rel="prefetch" href="/TIL/assets/js/142.0cfd3f82.js"><link rel="prefetch" href="/TIL/assets/js/143.19473e0b.js"><link rel="prefetch" href="/TIL/assets/js/15.90a881e5.js"><link rel="prefetch" href="/TIL/assets/js/16.c6139f2e.js"><link rel="prefetch" href="/TIL/assets/js/17.d4e90087.js"><link rel="prefetch" href="/TIL/assets/js/18.87c3b5ce.js"><link rel="prefetch" href="/TIL/assets/js/19.1a054d18.js"><link rel="prefetch" href="/TIL/assets/js/20.ab3d59cf.js"><link rel="prefetch" href="/TIL/assets/js/21.157e6d6b.js"><link rel="prefetch" href="/TIL/assets/js/22.4fa0c5e8.js"><link rel="prefetch" href="/TIL/assets/js/23.a07913eb.js"><link rel="prefetch" href="/TIL/assets/js/24.39ff2f92.js"><link rel="prefetch" href="/TIL/assets/js/25.dcc9b8a6.js"><link rel="prefetch" href="/TIL/assets/js/26.ac3bf32a.js"><link rel="prefetch" href="/TIL/assets/js/27.faf0f2f9.js"><link rel="prefetch" href="/TIL/assets/js/28.efd85a64.js"><link rel="prefetch" href="/TIL/assets/js/29.4fcd6f3f.js"><link rel="prefetch" href="/TIL/assets/js/3.43a682bb.js"><link rel="prefetch" href="/TIL/assets/js/30.f10f5d47.js"><link rel="prefetch" href="/TIL/assets/js/31.1581dc70.js"><link rel="prefetch" href="/TIL/assets/js/32.9b79ec86.js"><link rel="prefetch" href="/TIL/assets/js/33.2c6dbfb2.js"><link rel="prefetch" href="/TIL/assets/js/34.2486ba98.js"><link rel="prefetch" href="/TIL/assets/js/35.ee119d6a.js"><link rel="prefetch" href="/TIL/assets/js/36.8a5333d0.js"><link rel="prefetch" href="/TIL/assets/js/37.c88080f5.js"><link rel="prefetch" href="/TIL/assets/js/38.a0390359.js"><link rel="prefetch" href="/TIL/assets/js/39.09db164d.js"><link rel="prefetch" href="/TIL/assets/js/4.e3ffd4e9.js"><link rel="prefetch" href="/TIL/assets/js/40.f6cde728.js"><link rel="prefetch" href="/TIL/assets/js/41.3e3e0b40.js"><link rel="prefetch" href="/TIL/assets/js/42.9a708d07.js"><link rel="prefetch" href="/TIL/assets/js/43.c4422a54.js"><link rel="prefetch" href="/TIL/assets/js/44.0c8dd550.js"><link rel="prefetch" href="/TIL/assets/js/45.1be69e94.js"><link rel="prefetch" href="/TIL/assets/js/46.71b239b9.js"><link rel="prefetch" href="/TIL/assets/js/47.e08bac6b.js"><link rel="prefetch" href="/TIL/assets/js/48.9342fb51.js"><link rel="prefetch" href="/TIL/assets/js/49.dacec722.js"><link rel="prefetch" href="/TIL/assets/js/5.ec0e461c.js"><link rel="prefetch" href="/TIL/assets/js/50.e35578c1.js"><link rel="prefetch" href="/TIL/assets/js/51.48adfb25.js"><link rel="prefetch" href="/TIL/assets/js/52.294191c9.js"><link rel="prefetch" href="/TIL/assets/js/53.33416242.js"><link rel="prefetch" href="/TIL/assets/js/54.560ee88d.js"><link rel="prefetch" href="/TIL/assets/js/55.a0a39d65.js"><link rel="prefetch" href="/TIL/assets/js/56.aa8c533a.js"><link rel="prefetch" href="/TIL/assets/js/57.392d5865.js"><link rel="prefetch" href="/TIL/assets/js/58.8348ee63.js"><link rel="prefetch" href="/TIL/assets/js/59.f0cce1da.js"><link rel="prefetch" href="/TIL/assets/js/6.f401999e.js"><link rel="prefetch" href="/TIL/assets/js/60.d33f13c2.js"><link rel="prefetch" href="/TIL/assets/js/61.2bb6e4cf.js"><link rel="prefetch" href="/TIL/assets/js/62.7ec86312.js"><link rel="prefetch" href="/TIL/assets/js/63.ef18d5e8.js"><link rel="prefetch" href="/TIL/assets/js/64.e68e0ab7.js"><link rel="prefetch" href="/TIL/assets/js/65.d1a6e7ff.js"><link rel="prefetch" href="/TIL/assets/js/66.cfa993f6.js"><link rel="prefetch" href="/TIL/assets/js/67.12e7e0ae.js"><link rel="prefetch" href="/TIL/assets/js/69.6793a116.js"><link rel="prefetch" href="/TIL/assets/js/7.8e298897.js"><link rel="prefetch" href="/TIL/assets/js/70.35ea5a9f.js"><link rel="prefetch" href="/TIL/assets/js/71.595caee7.js"><link rel="prefetch" href="/TIL/assets/js/72.9fb1cb1c.js"><link rel="prefetch" href="/TIL/assets/js/73.740c3bb5.js"><link rel="prefetch" href="/TIL/assets/js/74.0822e067.js"><link rel="prefetch" href="/TIL/assets/js/75.41c01b57.js"><link rel="prefetch" href="/TIL/assets/js/76.b01fb1c9.js"><link rel="prefetch" href="/TIL/assets/js/77.132cdb3a.js"><link rel="prefetch" href="/TIL/assets/js/78.4f063220.js"><link rel="prefetch" href="/TIL/assets/js/79.2e845f1b.js"><link rel="prefetch" href="/TIL/assets/js/8.4c242db9.js"><link rel="prefetch" href="/TIL/assets/js/80.c90197ff.js"><link rel="prefetch" href="/TIL/assets/js/81.55d0cd01.js"><link rel="prefetch" href="/TIL/assets/js/82.e282f403.js"><link rel="prefetch" href="/TIL/assets/js/83.11c0d11d.js"><link rel="prefetch" href="/TIL/assets/js/84.308396e7.js"><link rel="prefetch" href="/TIL/assets/js/85.413462c7.js"><link rel="prefetch" href="/TIL/assets/js/86.801d6b29.js"><link rel="prefetch" href="/TIL/assets/js/87.d10d7f9f.js"><link rel="prefetch" href="/TIL/assets/js/88.28af4be3.js"><link rel="prefetch" href="/TIL/assets/js/89.89c63784.js"><link rel="prefetch" href="/TIL/assets/js/9.ce3af9e0.js"><link rel="prefetch" href="/TIL/assets/js/90.46e24de3.js"><link rel="prefetch" href="/TIL/assets/js/91.4e11dcf1.js"><link rel="prefetch" href="/TIL/assets/js/92.233aa3ef.js"><link rel="prefetch" href="/TIL/assets/js/93.a606c858.js"><link rel="prefetch" href="/TIL/assets/js/94.cb0fa4ec.js"><link rel="prefetch" href="/TIL/assets/js/95.ddeed60e.js"><link rel="prefetch" href="/TIL/assets/js/96.cd4f003c.js"><link rel="prefetch" href="/TIL/assets/js/97.fed730ee.js"><link rel="prefetch" href="/TIL/assets/js/98.7461b9b2.js"><link rel="prefetch" href="/TIL/assets/js/99.dd83b8b5.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.dd5ac3b9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">sso214's TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/TIL/study/" class="nav-link">
  Study
</a></div><div class="nav-item"><a href="/TIL/log/" class="nav-link">
  Log
</a></div><div class="nav-item"><a href="/TIL/memo/" class="nav-link">
  Memo
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="sso214" class="dropdown-title"><span class="title">sso214</span> <span class="arrow down"></span></button> <button type="button" aria-label="sso214" class="mobile-dropdown-title"><span class="title">sso214</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/TIL/info/" class="nav-link">
  Info
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/sso214" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/TIL/study/" class="nav-link">
  Study
</a></div><div class="nav-item"><a href="/TIL/log/" class="nav-link">
  Log
</a></div><div class="nav-item"><a href="/TIL/memo/" class="nav-link">
  Memo
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="sso214" class="dropdown-title"><span class="title">sso214</span> <span class="arrow down"></span></button> <button type="button" aria-label="sso214" class="mobile-dropdown-title"><span class="title">sso214</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/TIL/info/" class="nav-link">
  Info
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/sso214" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/TIL/Study/" aria-current="page" class="sidebar-link">Study</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Canvas</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Django</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Etc</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Interview</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NodeJs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ReactNative</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_25장-클래스"><a href="#_25장-클래스" class="header-anchor">#</a> 25장. 클래스</h1> <h2 id="_1-클래스는-프로토타입의-문법적-설탕인가"><a href="#_1-클래스는-프로토타입의-문법적-설탕인가" class="header-anchor">#</a> 1. 클래스는 프로토타입의 문법적 설탕인가?</h2> <p>자바스크립트는 프로토타입 기반 객체지향 언어<br>
(=클래스가 필요 없는 객체지향 프로그래밍 언어)<br>
ES5에서는 클래스 없이도 생성자 함수와 프로토타입을 이용해 객체지향 언어의 상속 구현 가능함</p> <p>ES6에서 도입된 클래스는 클래스 기반 객체지향 프로그래밍 언어와 흡사한 새로운 객체 생성 메크니즘을 제시함<br>
그렇다고 ES6의 클래스가 기존의 프로토타입 기반 객체지향 모델을 폐지하고<br>
새롭게 클래스 기반 객체지향 모델을 제공하는 것은 아님<br>
사실 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼<br>
사용할 수 있도록 하는 문법적 설탕이라고 볼 수도 있음</p> <p>클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 사용하지만 정확히 동일하게 동작하진 않음<br>
서로 유사하게 동작하지만 클래스가 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공함</p> <ul><li><p>클래스는 new 연산자 없이 호출하면 에러 발생함<br>
생성자 함수는 new 연산자 없이 호출한 경우 일반 함수로서 호출됨</p></li> <li><p>클래스는 상속을 지원하는 extends와 super 키워드를 지원함<br>
생성자 함수는 지원하지 않음</p></li> <li><p>클래스는 호이스팅이 발생하지 않는 것처럼 동작함<br>
함수 선언문으로 정의된 생성자 함수 - 함수 호이스팅,<br>
함수 표현식으로 작성된 생성자 함수 - 변수 호이스팅 발생함</p></li> <li><p>클래스 내의 모든 코드는 암묵적으로 strict mode가 지정되어 실행되며 해제할 수 없음<br>
생성자 함수는 암묵적으로 strict mode가 지정되지 않음</p></li> <li><p>클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트<br>
[[Enumerable]] 값 = false (열거되지 않음)</p></li></ul> <p>생성자 함수와 클래스는 프로토타입 기반의 객체지향을 구현했다는 점에서 매우 유사하지만<br>
클래스는 생성자 함수 기반의 객체 생성 방식보다 견고하고 명료함<br>
(그렇다고 클래스가 우월하다고 생각하진 않음)<br>
특히 클래스의 extends와 super 키워드는 상속 관계 구현을 더욱 간결하고 명료하게 함</p> <p>따라 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕이라고 보기보단<br>
새로운 객체 생성 메커니즘으로 보는게 조금 더 합당함</p> <h2 id="_2-클래스-정의"><a href="#_2-클래스-정의" class="header-anchor">#</a> 2. 클래스 정의</h2> <p>클래스 : 인스턴스를 생성하기 위한 생성자 함수<br>
클래스는 class 키워드를 사용해 정의함</p> <p>클래스명은 생성자 함수와 마찬가지로 파스칼 케이스를 사용하는 것이 일반적<br>
(파스칼 케이스를 사용하지 않아도 에러 발생하진 않음)<br>
일반적이진 않지만 함수와 마찬가지로 표현식으로 익명/기명 클래스 정의도 가능</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//클래스 선언문</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">//익명 클래스 표현식</span>
<span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//기명 클래스 표현식</span>
<span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>클래스를 표현식으로 정의할 수 있다는 것 = 클래스가 값으로 사용될 수 있는 일급 객체라는 의미<br>
클래스는 일급 객체로서 아래 같은 특징을 갖음</p> <ul><li>무명의 리터럴로 생성 가능, 즉 런타임에 생성 가능</li> <li>변수나 자료구조(객체, 배열 등)에 저장할 수 있음</li> <li>함수의 매개별수에 전달 가능</li> <li>함수의 반환값으로 사용 가능</li></ul> <p>클래스 = 함수. 따라 클래스는 값처럼 사용 가능한 일급 객체<br>
클래스 몸체에는 0개 이상의 메서드만 정의 가능함<br>
클래스 몸체에서 정의 가능한 메서드는 constructor(생성자), 프로토타입 메서드, 정적 메서드 세 가지가 있음<br>
클래스와 생성자 함수의 정의 방식은 형태적인 면에서 매우 유사함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//클래스 선언문</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">//생성자</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//인스턴스 생성 및 초기화</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">//name 프로퍼티는 public함</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//프로토타입 메서드</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//정적 메서드</span>
  <span class="token keyword">static</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//인스턴스 생성</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Leo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//인스턴스의 프로퍼티 참조</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Leo</span>
<span class="token comment">//프로토타입 메서드 호출</span>
me<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Hi! My name is Leo</span>
<span class="token comment">//정적 메서드 호출</span>
Person<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Hello!</span>
</code></pre></div><h2 id="_3-클래스-호이스팅"><a href="#_3-클래스-호이스팅" class="header-anchor">#</a> 3. 클래스 호이스팅</h2> <p>클래스는 함수로 평가됨</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//클래스 선언문</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//function</span>
</code></pre></div><p>클래스 선언문으로 정의한 클래스는 함수 선언문처럼 런타임 이전에 먼저 평가되어 함수 객체를 생성함<br>
이때 클래스가 평가되어 생성된 함수 객체 = 생성자 함수로서 호출할 수 있는 함수(즉, constructor)<br>
생성자 함수로서 호출할 수 있는 함수는 함수 객체를 생성하는 시점에 프로토타입도 같이 생성됨<br>
프로토타입과 생성자는 언제나 쌍으로 존재하기 때문</p> <p>단, 클래스는 클래스 정의 이전에 참조 불가능함</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//ReferenceError</span>
<span class="token comment">//클래스 선언문</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>클래스 선언문은 마치 호이스팅이 발생하지 않는 것처럼 보이지만 let/const 변수처럼 호이스팅이 발생함<br>
따라 클래스 선언문 이전에 일시적 사각지대(TDZ)에 빠져 호이스팅이 발생하지 않는 것처럼 동작함</p> <p>var, let, const, function, function*, class 키워드를 사용해 선언된 모든 식별자는 호이스팅 됨<br>
모든 선언문은 런타임 이전에 먼저 실행되기 때문</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

<span class="token punctuation">{</span>
  <span class="token comment">//호이스팅이 발생하지 않는다면 ''이 출력되어야 함</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//ReferenceError</span>
  
  <span class="token comment">// 클래스 선언문</span>
  <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_4-인스턴스-생성"><a href="#_4-인스턴스-생성" class="header-anchor">#</a> 4. 인스턴스 생성</h2> <p>클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성함<br>
함수는 new 연산자의 사용 여부에 따라 일반 함수로 호출되거나 생성자 함수로 호출되지만<br>
클래스는 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 new 연산자와 함께 호출해야 함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">//인스턴스 생성</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Person {}</span>

<span class="token comment">//클래스를 new 연산자 없이 호출하면 타입 에러 발생함</span>
<span class="token keyword">const</span> you <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//TypeError</span>
</code></pre></div><p>클래스 표현식으로 정의된 클래스의 경우 클래스를 가리키는 식별자를 사용해 인스턴스를 생성하지 않고<br>
기명 클래스 표현식의 클래스명을 사용해 인스턴스를 생성하면 에러 발생함<br>
이는 기명 함수 표현식과 마찬가지로 클래스 표현식에서 사용한 클래스명은 외부에서 접근 불가능하기 때문</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//함수 표현식과 마찬가지로 클래스를 가리키는 식별자로 인스턴스를 생성해야 함 </span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//클래스명 MyClass는 함수와 동일하게 클래스 몸체 내부에서만 유효한 식별자</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//ReferenceError</span>

<span class="token keyword">const</span> you <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//ReferneceError</span>
</code></pre></div><h2 id="_5-메서드"><a href="#_5-메서드" class="header-anchor">#</a> 5. 메서드</h2> <p>클래스 몸체에는 0개 이상의 메서드만 선언 가능함<br>
클래스 몸체에서 정의 가능한 메서드는 constructor(생성자), 프로토타입 메서드, 정적 메서드 3가지가 있음</p> <blockquote><p>ES11에 따르면 인스턴스 프로퍼티는 반드시 constructor 내부에서 정의해야 함<br>
하지만 현재 클래스 몸체에 메서드 뿐 아니라 프로퍼티를 직접 정의할 수 있는 새로운 표준 사양에 제안되어 있음<br>
이 제안 사양에 의해 머지 않아 클래스 몸체에서 메서드 뿐 아니라 프로퍼티도 정의할 수 있게 될 것으로 보임<br>
(크롬 같은 모던 브라우저에서는 이미 사용 가능함)</p></blockquote> <h3 id="_5-1-constructor"><a href="#_5-1-constructor" class="header-anchor">#</a> 5-1. constructor</h3> <ul><li>인스턴스를 생성하고 초기화하기 위한 특수한 메서드</li> <li>이름을 변경할 수 없음</li> <li>생성자 함수와 유사하지만 몇 가지 차이가 있음</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">//생성자</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//인스턴스 생성 및 초기화</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>클래스는 평가되어 함수 객체가 되며, 함수 객체 고유의 프로퍼티를 가짐<br>
함수와 동일하게 프로토타입과 연결되어 있으며 자신의 스코프체인을 구성함</p> <p>모든 함수 객체가 가지고 있는 prototype 프로퍼티가 가리키는 프로토타입 객체의<br>
constructor 프로퍼티는 클래스 자신을 가리키고 있음<br>
이는 클래스가 인스턴스를 생성하는 생성자 함수임을 의미함</p> <p>클래스가 생성한 인스턴스의 내부를 들여다보면 클래스의 constructor 내부에서<br>
this에 추가한 name 프로퍼티가 클래스가 생성한 인스턴스의 프로퍼티로 추가된 것을 볼 수 있음<br>
즉, 생성자 함수와 마찬가지로 constructor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 됨<br>
constructor 내부의 this = 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스를 가리킴</p> <p>클래스가 평가되어 생성된 함수 객체나 클래스가 생성한 인스턴스 어디에도 constructor 메서드가 보이지 않는데<br>
이는 클래스 몸체에 정의한 constructor가 단순한 메서드가 아님을 의미<br>
constructor는 메서드로 해석되는게 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 됨<br>
즉, 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성됨</p> <blockquote><p>클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티는<br>
이름이 같아 혼동하기 쉽지만 직접적인 관련이 없음.<br>
프로토타입의 constructor 프로퍼티 : 모든 프로토타입들이 가지고 있는 프로퍼티이며, 생성자 함수를 가리킴</p></blockquote> <ul><li><p><strong>constructor는 클래스 내에 최대 한 개만 존재 가능</strong><br>
만약 클래스가 2개 이상의 constructor를 포함하면 문법 에러 발생함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token comment">//SyntaxError</span>
</code></pre></div></li> <li><p><strong>constructor는 생략 가능</strong><br>
constructor 생략 시 클래스에 빈 constructor가 암묵적으로 정의됨<br>
constructor를 생략한 클래스는 빈 객체를 생성함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">//constructor 생략 시 아래처럼 빈 constructor가 암묵적으로 정의됨</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//빈 객체가 생성됨</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Person {}</span>
</code></pre></div></li> <li><p><strong>프로퍼티가 추가되어 초기화된 인스턴스 생성</strong><br>
프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 constructor 내부에서 this에 인스턴스 프로퍼티를 추가함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//고정값으로 인스턴스 초기화</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Leo'</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> <span class="token string">'Seoul'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//인스턴스 프로퍼티가 추가됨</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Person {name: 'Leo', address: 'Seoul'}</span>
</code></pre></div></li> <li><p><strong>클래스 외부에서 인스턴스 프로퍼티의 초기값 전달</strong><br>
인스턴스 생성 시 클래스 외부에서 인스턴스 프로퍼티의 초기값을 전달하려면<br>
constructor에 매개변수를 선언하고 인스턴스를 생성할 때 초기값을 전달함<br>
이때 초기값은 constructor 매개변수에 전달됨</p> <p>이처럼 constructor 내에서는 인스턴스의 생성과 동시에 인스턴스 프로퍼티를 통해 인스턴스 초기화를 실행함<br>
따라 인스턴스를 초기화하기 위해서는 constructor를 생략하면 안됨</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> address</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//인수로 인스턴스 초기화</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//인수로 초기값 전달. 초기값은 constructor에 전달됨</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Leo'</span><span class="token punctuation">,</span> <span class="token string">'Seoul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Person {name: 'Leo', address: 'Seoul'}</span>
</code></pre></div></li> <li><p><strong>constructor는 별도의 반환문을 갖지 않아야 함</strong><br>
new 연산자와 함께 클래스 호출 시 암묵적으로 this(인스턴스)를 반환하는데<br>
만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 않고 return 문에 명시한 객체가 반환됨<br>
(명시적으로 원시값을 반환한 경우 원시값 반환은 무시되고 암묵적으로 this가 반환됨)</p> <p>constructor 내부에서 명시적으로 this가 아닌 값을 반환하는 것은 클래스의 기본 동작을 훼손함<br>
따라 constructor 내부에서 return 문은 반드시 생략해야함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token comment">//명시적으로 객체 반환 시 암묵적인 this 반환은 무시됨</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//constructor에서 명시적으로 반환된 빈 객체가 반환됨</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Leo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{}</span>
</code></pre></div></li></ul> <h3 id="_5-2-프로토타입-메서드"><a href="#_5-2-프로토타입-메서드" class="header-anchor">#</a> 5-2. 프로토타입 메서드</h3> <ul><li><p>클래스 몸체에 정의한 메서드는 인스턴스의 프로토타입에 존재하는 프로토타입 메서드가 됨<br>
클래스 몸체에 정의한 메서드는 생성자 함수에 의한 객체 생성 방식과 달리<br>
클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 됨</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">//생성자</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//인스턴스 생성 및 초기화</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//프로토타입 메서드</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Leo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
me<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Hi! My name is Leo</span>
</code></pre></div></li> <li><p>생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 됨<br>
프로토타입 체인은 기존의 모든 객체 생성 방식 뿐 아니라 클래스에 의해 생성된 인스턴스에도 동일하게 적용됨<br>
(생성자 함수의 역할을 클래스가 할 뿐)</p> <p>결국 클래스는 생성자 함수와 같이 인스턴스를 생성하는 생성자 함수라고 볼 수 있음<br>
(생성자 함수와 마찬가지로 프로토타입 기반의 객체 생성 메커니즘)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//me 객체의 프로토타입은 Person.prototype</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">//true</span>
me <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
ㅣ
<span class="token comment">//Person.prototype의 프로토타입은 Object.prototype</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">//true</span>
me <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

<span class="token comment">//me 객체의 constructor는 Person 클래스</span>
me<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div></li></ul> <h3 id="_5-3-정적-메서드"><a href="#_5-3-정적-메서드" class="header-anchor">#</a> 5-3. 정적 메서드</h3> <p>정적 메서드 : 인스턴스를 생성하지 않아도 호출할 수 있는 메서드</p> <p>생성자 함수 : 명시적으로 생성자 함수에 메서드를 추가해 정적 메서드 생성<br>
클래스 : 메서드에 static 키워드를 붙이면 정적 메서드(클래스 메서드)가 됨</p> <ul><li><p><strong>정적 메서드는 클래스 정의 인스턴스를 생성하지 않아도 호출 가능함</strong><br>
정적 메서드는 클래스에 바인딩된 메서드가 됨<br>
클래스는 함수 객체로 평가되므로 자신의 프로퍼티/메서드를 소유 가능<br>
클래스는 클래스 정의(클래스 선언문이나 클래스 표현식)가 평가되는 시점에 함수 객체가 되므로<br>
인스턴스와 달리 별다른 생성 과정이 필요 없음</p></li> <li><p><strong>정적 메서드는 인스턴스로 호출 불가함</strong><br>
인스턴스 프로토타입 체인 상에는 클래스가 존재하지 않으므로 인스턴스로 클래스의 메서드를 상속받을 수 없음<br>
정적 메서드는 프로토타입 메서드처럼 인스턴스로 호출하지 않고 클래스로 호출</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//생성자 함수</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//정적 메서드</span>
Person<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//정적 메서드 호출</span>
Person<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Hi!</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">//생성자</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//인스턴스 생성 및 초기화</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//정적 메서드</span>
  <span class="token keyword">static</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//정적 메서드는 클래스로 호출</span>
<span class="token comment">//정적 메서드는 인스턴스 없이도 호출 가능함</span>
Person<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Hi!</span>

<span class="token comment">//인스턴스 생성</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Leo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
me<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//TypeError</span>
</code></pre></div><h3 id="_5-4-정적-메서드와-프로토타입-메서드의-차이"><a href="#_5-4-정적-메서드와-프로토타입-메서드의-차이" class="header-anchor">#</a> 5-4. 정적 메서드와 프로토타입 메서드의 차이</h3> <ul><li>정적 메서드와 프로토타입 메서드는 자신이 속해있는 프로토타입 체인이 다름</li> <li>정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출함</li> <li>정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조 가능함</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>
  <span class="token comment">//정적 메서드</span>
  <span class="token keyword">static</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">width<span class="token punctuation">,</span> height</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> width <span class="token operator">*</span> height<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Square<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//100</span>
</code></pre></div><p>위의 코드에서 정적 메서드 area는 인스턴스 프로퍼티를 참조하지 않음<br>
만약 인스턴스 프로퍼티를 참조해야 하는 경우라면 정적 메서드 대신 프로토타입 메서드를 사용해야 함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">width<span class="token punctuation">,</span> height</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> width<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//프로토타입 메서드</span>
  <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>height<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> square <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Square</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>square<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//10</span>
</code></pre></div><p>메서드 내부의 this는 메서드를 호출한 객체, 즉 메서드명 앞에 마침표 연산자 앞에 기술한 객체에 바인딩 됨<br>
프로토타입 메서드와 정적 메서드 내부의 this 바인딩이 다름</p> <ul><li>프로토타입 메서드 :<br>
인스턴스를 호출해야 하므로 프로토타입 메서드 내부의 this는 프로토타입 메서드를 호출한 인스턴스를 가리킴</li> <li>정적 메서드 :<br>
클래스로 호출해야 하므로 정적 메서드 내부의 this는 인스턴스가 아닌 클래스를 가리킴</li></ul> <p>따라 메서드 내부에서 인스턴스 프로퍼티를 참조할 필요가 있다면<br>
this를 사용해야 하며, 이런 경우 프로토타입 메서드로 정의해야 함</p> <p>물론 메서드 내부에서 this를 사용하지 않더라도 프로토타입 메서드로 정의 가능하지만<br>
반드시 인스턴스를 생성한 다음 인스턴스로 호출해야 하므로<br>
this를 사용하지 않는 메서드는 정적 메서드로 정의하는 것이 좋음</p> <p>표준 빌트인 객체는 다양한 정적 메서드를 가지고 있음<br>
이들 정적 메서드는 애플리케이션 전역에서 사용할 유틸리티 함수<br>
예를 들어, 정적 메서드 Math.max는 인스턴스와 상관없이 애플리케이션 전역에서 사용할 유틸리티 함수</p> <p>이처럼 클래스 또는 생성자 함수를 하나의 네임페이스로 사용해 정적 메서드를 모아놓으면<br>
이름 충돌 가능성을 줄여주고 관련 함수들을 구조화할 수 있는 효과가 있음<br>
이같은 이유로 정적 메서드는 에플리케이션 전역에서 사용할 유틸리티 함수를<br>
전역 함수로 정의하지 않고 메서드로 구조화할 때 유용함</p> <blockquote><p>ES6에서는 빌트인 전역 함수(isFinit, isNaN, parseFloat, parseInt 등)를<br>
표준 빌트인 객체 Number의 정적 메서드로 추가 구현함<br>
Number의 정적 메서드(isFinit, isNaN, parseFloat, parseInt)는<br>
빌트인 전역 함수(isFinit, isNaN, parseFloat, parseInt)보다 엄격함</p></blockquote> <h3 id="_5-5-클래스에서-정의한-메서드의-특징"><a href="#_5-5-클래스에서-정의한-메서드의-특징" class="header-anchor">#</a> 5-5. 클래스에서 정의한 메서드의 특징</h3> <ul><li>function 키워드를 생략한 메서드 축약 표현을 사용함</li> <li>객체 리터럴과는 달리 클래스에 메서드를 정의할 때는 콤마가 필요 없음</li> <li>암묵적으로 static mode로 실행됨</li> <li>for...in문이나 Object.Keys 등ㄹ으로 열거 불가능<br>
프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이기 떄문</li> <li>내부 메서드 [[Construct]]를 갖지 않는 non-constructor.<br>
따라 new 연산자와 함께 호출할 수 없음</li></ul> <h2 id="_6-클래스의-인스턴스-생성-과정"><a href="#_6-클래스의-인스턴스-생성-과정" class="header-anchor">#</a> 6. 클래스의 인스턴스 생성 과정</h2> <p>new 연산자와 함께 클래스 호출 시 생성자 함수와 마찬가지로 클래스의 내부 메서드 [[Construct]]가 호출됨<br>
클래스는 new 연산자 없이 호출 불가능<br>
아래와 같은 과정을 거쳐 인스턴스가 생성됨</p> <ol><li><strong>인스턴스 생성과 this 바인딩</strong><br>
new 연산자와 함께 클래스 호출 시 constructor의 내부 코드가 실행되기 전 암묵적으로 빈 객체가 생성됨<br>
이 빈 객체가 바로 클래스가 생성한 인스턴스(아직 완성되지 않은)<br>
인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정됨<br>
암묵적으로 생성된 빈 객체(인스턴스)는 this에 바인딩 됨<br>
따라 constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킴</li> <li><strong>인스턴스 초기화</strong><br>
constructor의 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화 함<br>
즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고<br>
constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값을 초기화 함<br>
만약 constructor가 생략되었다면 이 과정도 생략됨</li> <li><strong>인스턴스 반환</strong><br>
클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환됨</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">//생성자</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//1. 암묵적으로 인스턴스가 생성되고 this에 바인딩 됨</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Person {}</span>
    consnole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

    <span class="token comment">//2. this에 바인딩되어 있는 인스턴스를 초기화 함</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>

    <span class="token comment">//3. 완성된 인스턴스가 바인딩 된 this가 암묵적으로 반환됨</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_7-프로퍼티"><a href="#_7-프로퍼티" class="header-anchor">#</a> 7. 프로퍼티</h2> <h3 id="_7-1-인스턴스-프로퍼티"><a href="#_7-1-인스턴스-프로퍼티" class="header-anchor">#</a> 7-1. 인스턴스 프로퍼티</h3> <p><strong>인스턴스의 프로퍼티는 constructor 내부에서 정의해야 함</strong><br>
constructor 내부 코드가 실행되기 이전 constructor 내부 this에는<br>
이미 클래스가 암묵적으로 생성한 인스턴스인 빈 객체가 바인딩되어 있음</p> <p>생성자 함수에서 생성자 함수가 정의할 인스턴스의 프로퍼티를 정의하는 것과 마찬가지로<br>
constructor 내부에서 this에 인스턴스 프로퍼티를 추가함<br>
이로써 클래스가 암묵적으로 생성한 빈 객체(=인스턴스)에 프로퍼티가 추가되어 인스턴스가 초기화됨</p> <p>constructor 내부에서 this에 추가한 프로퍼티는 언제나 클래스가 생성한 인스턴스의 프로퍼티가 됨<br>
ES6의 클래스는 다른 객체지향 언어처럼 접근 제한자를 지원하지 않음<br>
따라 인스턴스 프로퍼티는 언제나 public 함<br>
(private한 프로퍼티를 정의할 수 있는 사양은 현재 제안 중에 있음)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//인스턴스 프로퍼티</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">//name 프로퍼티는 public 함</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Leo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//name은 public함</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Leo</span>
</code></pre></div><h3 id="_7-2-접근자-프로퍼티"><a href="#_7-2-접근자-프로퍼티" class="header-anchor">#</a> 7-2. 접근자 프로퍼티</h3> <p>접근자 프로퍼티 : 자체적으로는 값([[Value]]내부 슬롯)을 갖지 않고 접근자 함수로 구성된 프로퍼티<br>
접근자 프로퍼티는 클래스에서도 사용 가능함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">firstName<span class="token punctuation">,</span> lastName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//fullName은 접근자 함수로 구성된 접근자 프로퍼티</span>
  <span class="token keyword">get</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">set</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">]</span> <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Park'</span><span class="token punctuation">,</span> <span class="token string">'Leo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//데이터 프로퍼티를 통한 프로퍼티 값의 참조</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>me<span class="token punctuation">.</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>me<span class="token punctuation">.</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Park Leo</span>

<span class="token comment">//접근자 프로퍼티를 통한 프로퍼티 값의 저장</span>
<span class="token comment">//접근자 프로퍼티 fullName에 값 저장 시 setter 함수 호출됨</span>
me<span class="token punctuation">.</span>fullName <span class="token operator">=</span> <span class="token string">'Soo Lee'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{firstName: 'Soo', lastName: 'Lee'}</span>

<span class="token comment">//접근자 프로퍼티를 통한 프로퍼티 값의 참조</span>
<span class="token comment">//접근자 프로퍼티 fullName에 접근 시 getter 함수 호출됨</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Soo Lee</span>

<span class="token comment">//fullName은 접근자 프로퍼티</span>
<span class="token comment">//접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰를 갖음  </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'fullName'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//{get:f, set:f, enumerable:false, configurable:true}</span>
</code></pre></div><p>접근자 프로퍼티는 접근자 함수(getter/setter 함수)로 구성되어 있음</p> <ul><li>getter<br>
인스턴스 프로퍼티에 접근 시마다 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용<br>
메서드명 앞에 get 키워드를 사용해 정의함</li> <li>setter<br>
인스턴스 프로퍼티에 값을 할당 시마다 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용<br>
메서드명 앞에 set 키워드를 사용해 정의함</li></ul> <p>getter/setter 이름은 인스턴스 프로퍼티처럼 사용됨<br>
다시 말해 호출하는 것이 아니라 프로퍼티처럼 참조/할당하는 형식으로 사용하며,<br>
참조/할당 시에 내부적으로 getter/setter가 호출됨</p> <p>getter 함수는 뭔가 취득할 때 사용하기 때문에 반드시 무언가를 반환해야 하고,<br>
setter 함수는 뭔가를 프로퍼티에 할당할 때 사용하기 떄문에 반드시 매개변수가 있어야 함<br>
(setter는 단 하나의 값만 할당받기 때문에 단 하나의 매개변수만 선언 가능함)</p> <p>클래스의 메서드는 기본적으로 프로토타입 메서드가 됨<br>
따라 클래스의 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 됨</p> <h3 id="_7-3-클래스-필드-정의-제안"><a href="#_7-3-클래스-필드-정의-제안" class="header-anchor">#</a> 7-3. 클래스 필드 정의 제안</h3> <p>클래스 필드(필드/멤버) : 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어</p> <p>자바의 클래스 필드는 마치 클래스 내부에서 변수처럼 사용됨</p> <div class="language- extra-class"><pre class="language-text"><code>// 자바의 클래스 정의
public class Person {
  // ① 클래스 필드 정의
  // 클래스 필드는 클래스 몸체에 this 없이 선언해야 한다.
  private String firstName = &quot;&quot;;
  private String lastName = &quot;&quot;;
  
  // 생성자
  Person(String firstName, String lastName) {
    // ③ this는 언제나 클래스가 생성할 인스턴스를 가리킨다.
    this.firstName = firstName;
    this.lastName = lastName;
  }
  
  public String getFullName() {
    // ② 클래스 필드 참조
    // this 없이도 클래스 필드를 참조할 수 있다.
    return firstName + &quot; &quot; + lastName;
  }
}
</code></pre></div><ul><li>자바의 클래스에서는 ①과 같이 클래스 필드를 변수처럼 클래스 몸체에 this 없이 선언함</li> <li>자바의 클래스에서는 ②와 같이 this를 생략해도 클래스 필드를 참조할 수 있음</li> <li>클래스 기반 객체지향 언어의 this는 언제나 클래스가 생성할 인스턴스를 가리킴<br>
③과 같이 this는 주로 클래스 필드가 생성자 또는 메서드의 매개변수명과 동일할 때 구분하기 위해 사용함</li></ul> <p>자바스크립트의 클래스 몸체에는 메서드만 선언 가능<br>
따라서 클래스 몸체에 자바와 유사하게 클래스 필드를 선언하면 문법 에러가 발생함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">// 클래스 필드 정의</span>
  name <span class="token operator">=</span> <span class="token string">'Lee'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>하지만 현재 인스턴스 프로퍼티를 마치 클래스 기반 객체지향 언어의 클래스 필드처럼 정의 가능한<br>
새로운 표준 사양인 “Class field declarations”가 TC39 프로세스 11의 stage 3에 제안되어 있음<br>
따라 위 코드를 최신 브라우저나 최신 Node.js에서 실행 시 문법 에러가 발생하지 않고 정상 동작함</p> <p>해당 클래스 필드 정의 제안은 아직 ECMAScript의 정식 표준 사양으로 승급되지 않았지만<br>
최신 브라우저와 최신 Node.js는 표준 사양으로 승급이 확실시되는 이 제안을 미리 구현해 놓음<br>
따라 최신 브라우저와 최신 Node.js에서는 클래스 필드를 클래스 몸체에 정의할 수 있음</p> <ul><li><p>클래스 몸체에서 클래스 필드를 정의하는 경우 this에 클래스 필드를 바인딩해서는 안 됨<br>
this는 클래스의 constructor와 메서드 내에서만 유효함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">// this에 클래스 필드를 바인딩해서는 안 됨</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span> <span class="token comment">// SyntaxError: Unexpected token '.'</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>클래스 필드를 참조하는 경우 클래스 기반 객체지향 언어에서는 this를 생략 가능하나<br>
자바스크립트에서는 this를 반드시 사용해야 함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">// 클래스 필드</span>
  name <span class="token operator">=</span> <span class="token string">'Leo'</span><span class="token punctuation">;</span>
  
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//ReferenceError</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>클래스 필드에 초기값을 할당하지 않으면 undefined를 갖음</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">//클래스 필드 초기화하지 않으면 undefined를 갖음</span>
  name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Person {name: undeinfed}</span>
</code></pre></div></li> <li><p>인스턴스를 생성할 때 외부의 초기값으로 클래스 필드를 초기화해야 할 필요가 있다면<br>
constructor에서 클래스 필드를 초기화해야 함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//클래스 필드 초기화</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Leo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Person {name: 'Leo'}</span>
</code></pre></div><p>이처럼 인스턴스 생성 시 클래스 필드를 초기화 해야된다면 constructor 밖에서 클래스 필드를 정의할 필요가 없음<br>
클래스 필드를 초기화하려면 어차피 constructor 내부에서 클래스 필드를 참조해 초기값을 할당해야 함<br>
이때 this(=클래스가 생성한 인스턴스)에 클래스 필드에 해당하는 프로퍼티가 없다면 자동 추가되기 때문</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Person {name: &quot;Lee&quot;}</span>
</code></pre></div></li> <li><p>함수는 일급 객체이므로 함수를 클래스 필드에 할당할 수 있음<br>
따라 클래스 필드를 통해 메서드를 정의할 수도 있음</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">// 클래스 필드에 문자열을 할당</span>
  name <span class="token operator">=</span> <span class="token string">'Lee'</span><span class="token punctuation">;</span>
  <span class="token comment">// 클래스 필드에 함수를 할당</span>
  <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token comment">// 화살표 함수로 정의할 수도 있다.</span>
<span class="token comment">// getName = () =&gt; this.name;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'delete'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Person {name: &quot;Lee&quot;, getName: ƒ}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Lee</span>
</code></pre></div><p>이처럼 클래스 필드에 함수를 할당하는 경우 인스턴스 메서드가 됨<br>
모든 클래스 필드는 인스턴스 프로퍼티가 되기 때문<br>
따라서 클래스 필드에 함수를 할당하는 것은 권장하지 않음</p></li></ul> <p>클래스 필드 정의 제안으로 인해 인스턴스 프로퍼티를 정의하는 방식은 두 가지가 됨<br>
인스턴스 생성 시 외부 초기값으로 클래스 필드를 초기화할 필요가 있다면<br>
constructor에서 인스턴스 프로퍼티를 정의하는 기존 방식을 사용하고,<br>
인스턴스를 생성할 때 외부 초기값으로 클래스 필드를 초기화할 필요가 없다면<br>
기존의 constructor에서 인스턴스 프로퍼티를 정의하는 방식과 클래스 필드 정의 제안 모두 사용할 수 있음</p> <h4 id="클래스-필드와-화살표-함수"><a href="#클래스-필드와-화살표-함수" class="header-anchor">#</a> &lt;클래스 필드와 화살표 함수&gt;</h4> <p>클래스 필드에 화살표 함수를 할당해 화살표 함수 내부의 this가 인스턴스를 가리키게 하는 경우도 있음<br>
인스턴스가 여러 개 생성된다면 이 방법도 메모리의 손해를 감수해야 함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// increase 메서드를 이벤트 핸들러로 등록</span>
    <span class="token comment">// 이벤트 핸들러 내부의 this는 DOM 요소(this.$button)를 가리킨다.</span>
    <span class="token comment">// 하지만 increase는 화살표 함수로 정의되어 있으므로</span>
    <span class="token comment">// increase 내부의 this는 인스턴스를 가리킨다.</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$button<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>increase<span class="token punctuation">;</span>
    <span class="token comment">// 만약 increase가 화살표 함수가 아니라면 bind 메서드를 사용해야 한다.</span>
    <span class="token comment">// $button.onclick = this.increase.bind(this);</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 인스턴스 메서드</span>
  <span class="token comment">// 화살표 함수 내부의 this는 언제나 상위 컨텍스트의 this를 가리킨다.</span>
  <span class="token function-variable function">increase</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$button<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token operator">++</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p><strong>Technical Committee 39(TC39)</strong><br>
ECMA 인터내셔널은 ECMAScript 이외에도 다양한 기술의 사양을 관리하고,<br>
이들 사양을 관리하는 주체인 기술 위원회Technical Committee도 여럿 존재함.<br>
여러 사양 중 ECMA-262 사양(ECMAScript)의 관리를 담당하는 위원회가 바로 TC39.<br>
TC39는 구글, 애플, 마이크로소프트, 모질라 등 브라우저 벤더와<br>
페이스북, 트위터와 같이 ECMA-262 사양(ECMAScript)을 제대로 준수해야 하는 기업으로 구성되어 있음</p></blockquote> <blockquote><p><strong>TC39 프로세스</strong><br>
TC39 프로세스는 ECMAScript에 새로운 표준 사양을 추가하기 위해 공식적으로 명문화해 놓은 과정<br>
0단계부터 4단계까지 총 5개의 단계로 구성되어 있고, 상위 단계로 승급하기 위한 명시적인 조건들이 있음<br>
승급 조건을 충족시킨 제안은 TC39의 동의를 통해 다음 단계로 승급됨<br> <br>
TC39 프로세스는 다음과 같은 단계를 거쳐 최종적으로 ECMAScript의 새로운 표준 사양이 됨<br>
stage 0: strawman → stage 1: proposal → stage 2: draft →<br>
stage 3: candidate → stage 4: finished<br> <br>
stage 3까지 승급한 제안은 심각한 문제가 없는 한 변경되지 않고 대부분 stage 4로 승급됨<br>
stage 4까지 승급한 제안은 큰 이변이 없는 이상, 차기 ECMAScript 버전에 포함됨<br>
현재 TC39 프로세스에 올라와 있는 제안을 확인하려면 ECMAScript proposals를 참고</p></blockquote> <h3 id="_7-4-private-필드-정의-제안"><a href="#_7-4-private-필드-정의-제안" class="header-anchor">#</a> 7-4. private 필드 정의 제안</h3> <p>자바스크립트는 캡슐화를 완전하게 지원하지 않음<br>
ES6의 클래스도 생성자 함수처럼 접근 제한자를 지원하지 않음<br>
따라 인스턴스 프로퍼티는 인스턴스를 통해 클래스 외부에서 언제나 참조 가능함 (언제나 public)<br>
클래스 필드 정의 제안을 사용해도 클래스 필드는 기본적으로 public하기 때문에 외부에 그대로 노출됨</p> <p>다행히 TC39 프로세스의 stage 3에는 private 필드를 정의할 수 있는 새로운 표준 사양이 제안되어 있음<br>
이 제안도 표준 사양으로 승급이 확실시되어<br>
최신 브라우저(Chrome 74 이상)와 최신 Node.js(버전 12 이상)에 이미 구현되어 있음</p> <ul><li>private 필드의 선두에는 #을 붙여줌</li> <li>private 필드를 참조할 때도 #을 붙어주어야 함</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">// private 필드 정의</span>
  #name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// private 필드 참조</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// private 필드 #name은 클래스 외부에서 참조할 수 없음</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>#name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// SyntaxError</span>
</code></pre></div><ul><li><p>public 필드는 어디서든 참조할 수 있지만 private 필드는 클래스 내부에서만 참조 가능</p> <table><thead><tr><th style="text-align:left;">접근 가능성</th> <th style="text-align:center;">public</th> <th style="text-align:center;">private</th></tr></thead> <tbody><tr><td style="text-align:left;">클래스 내부</td> <td style="text-align:center;">◯</td> <td style="text-align:center;">◯</td></tr> <tr><td style="text-align:left;">자식 클래스 내부</td> <td style="text-align:center;">◯</td> <td style="text-align:center;">✕</td></tr> <tr><td style="text-align:left;">클래스 인스턴스를 통한 접근</td> <td style="text-align:center;">◯</td> <td style="text-align:center;">✕</td></tr></tbody></table></li> <li><p>클래스 외부에서 private 필드에 직접 접근할 수 있는 방법은 없지만<br>
접근자 프로퍼티를 통해 간접적으로 접근하는 방법은 유효함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">// private 필드 정의</span>
  #name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// name은 접근자 프로퍼티</span>
  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// private 필드를 참조하여 trim한 다음 반환함</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#name<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">' Lee '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>private 필드는 반드시 클래스 몸체에 정의해야 함<br>
(private 필드를 직접 constructor에 정의하면 에러가 발생함)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// private 필드는 클래스 몸체에서 정의해야 한다.</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// SyntaxError</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <blockquote><p>Typescript<br>
자바스크립트의 상위 확장 superset인 타입스크립트는 접근 제한자를 모두 지원하며,<br>
의미 또한 기본적으로 동일함</p></blockquote> <h3 id="_7-5-static-필드-정의-제안"><a href="#_7-5-static-필드-정의-제안" class="header-anchor">#</a> 7-5. static 필드 정의 제안</h3> <p>클래스에는 static 키워드를 사용해 정적 메서드를 정의 할 수 있지만<br>
static 키워드를 사용해 정적 필드를 정의할 수는 없음</p> <p>하지만 static public 필드, static private 필드, static private 메서드를 정의할 수 있는<br>
새로운 표준 사양인 “Static class features”가 TC39 프로세스의 stage 3에 제안되어 있음<br>
이 제안 중에서 static public/private 필드는 최신 브라우저와 최신 Node.js에 이미 구현되어 있음</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyMath</span> <span class="token punctuation">{</span>
  <span class="token comment">// static public 필드 정의</span>
  <span class="token keyword">static</span> <span class="token constant">PI</span> <span class="token operator">=</span> <span class="token number">22</span> <span class="token operator">/</span> <span class="token number">7</span><span class="token punctuation">;</span>
  <span class="token comment">// static private 필드 정의</span>
  <span class="token keyword">static</span> #num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token comment">// static 메서드</span>
  <span class="token keyword">static</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">++</span>MyMath<span class="token punctuation">.</span>#num<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>MyMath<span class="token punctuation">.</span><span class="token constant">PI</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3.142857142857143</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>MyMath<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 11</span>
</code></pre></div><h2 id="_8-상속에-의한-클래스-확장"><a href="#_8-상속에-의한-클래스-확장" class="header-anchor">#</a> 8. 상속에 의한 클래스 확장</h2> <h3 id="_8-1-클래스-상속과-생성자-함수-상속"><a href="#_8-1-클래스-상속과-생성자-함수-상속" class="header-anchor">#</a> 8-1. 클래스 상속과 생성자 함수 상속</h3> <p>상속에 의한 클래스 확장은 프로토타입 기반 상속과는 다른 개념</p> <ul><li>프로토타입 기반 상속: 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념</li> <li><strong>상속에 의한 클래스 확장 : 기존 클래스를 상속받아 새로운 클래스를 확장해 정의하는 것</strong></li></ul> <p>클래스와 생성자 함수는 인스턴스 생성 가능한 함수라는 점에서 매우 유사하지만<br>
클래스는 상속을 통해 기존 클래스를 확장할 수 있는 문법이 기본적으로 제공되는 반면 생성자 함수는 그렇지 않음<br>
상속에 의한 클래스 확장은 코드 재사용 관점에서 매우 유용함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">age<span class="token punctuation">,</span> weight</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'eat'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'move'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 상속을 통해 Animal 클래스를 확장한 Bird 클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'fly'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> bird <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bird</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bird<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Bird {age: 1, weight: 5}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bird <span class="token keyword">instanceof</span> <span class="token class-name">Bird</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bird <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bird<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// eat</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bird<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// move</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bird<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fly</span>
</code></pre></div><p>클래스는 상속을 통해 다른 클래스를 확장할 수 있는 문법인 extends 키워드가 기본적으로 제공됨<br>
extends 키워드를 사용한 클래스 확장은 간편하고 직관적임<br>
하지만 생성자 함수는 이런 문법이 제공되지 않음</p> <p>자바스크립트는 클래스 기반 언어가 아니기 때문에 생성자 함수를 이용해 클래스를<br>
흉내내려는 시도를 권장하지 않지만 의사 클래스 상속 패턴을 사용해 상속에 의한 클래스 확장을 흉내내기도 함<br>
(클래스의 등장으로 인해 의사 클래스 상속 패턴은 더 이상 필요하지 않음)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 의사 클래스 상속(pseudo classical inheritance) 패턴</span>
<span class="token keyword">var</span> Animal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token parameter">age<span class="token punctuation">,</span> weight</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'eat'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">move</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'move'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Animal<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Animal 생성자 함수를 상속하여 확장한 Bird 생성자 함수</span>
<span class="token keyword">var</span> Bird <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">Bird</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Animal 생성자 함수에게 this와 인수를 전달하면서 호출</span>
    <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Bird.prototype을 Animal.prototype을 프로토타입으로 갖는 객체로 교체</span>
  <span class="token class-name">Bird</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Bird.prototype.constructor을 Animal에서 Bird로 교체</span>
  <span class="token class-name">Bird</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Bird<span class="token punctuation">;</span>
  <span class="token class-name">Bird</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">fly</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'fly'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Bird<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> bird <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bird</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bird<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Bird {age: 1, weight: 5}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bird<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// eat</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bird<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// move</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bird<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fly</span>
</code></pre></div><h3 id="_8-2-extends-키워드"><a href="#_8-2-extends-키워드" class="header-anchor">#</a> 8-2. extends 키워드</h3> <p>상속을 통해 클래스를 확장하려면 extends 키워드를 사용해 상속받을 클래스를 정의함</p> <ul><li>서브클래스 : 상속을 통해 확장된 클래스 (=파생 클래스/자식 클래스)</li> <li>수퍼클래스 : 서브클래스에게 상속된 클래스 (=베이스 클래스/부모 클래스)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 수퍼(베이스/부모)클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 서브(파생/자식)클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>extends 키워드의 역할 : 수퍼클래스와 서브클래스 간의 상속 관계를 설정<br>
클래스도 프로토타입을 통해 상속 관계를 구현함</p> <p>수퍼클래스와 서브클래스는 인스턴스의 프로토타입 체인 뿐 아니라 클래스 간의 프로토타입 체인도 생성함<br>
이를 통해 프로토타입 메서드, 정적 메서드 모두 상속 가능함</p> <h3 id="_8-3-동적-상속"><a href="#_8-3-동적-상속" class="header-anchor">#</a> 8-3. 동적 상속</h3> <p>extends 키워드는 클래스 뿐 아니라 생성자 함수를 상속받아 클래스를 확장할 수도 있음<br>
단, extends 키워드 앞에는 반드시 클래스가 와야 함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 생성자 함수</span>
<span class="token keyword">function</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 생성자 함수를 상속받는 서브클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> derived <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>derived<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Derived {a: 1}</span>
</code></pre></div><p>extends 키워드 다음에는 클래스 뿐 아니라 [[Construct]] 내부 메서드를 갖는<br>
함수 객체로 평가될 수 있는 모든 표현식 사용 가능함<br>
이를 통해 동적으로 상속받을 대상을 결정할 수 있음</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Base1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Base2</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">let</span> condition <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token comment">// 조건에 따라 동적으로 상속 대상을 결정하는 서브클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>condition <span class="token operator">?</span> Base1 <span class="token operator">:</span> Base2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">const</span> derived <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>derived<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Derived {}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>derived <span class="token keyword">instanceof</span> <span class="token class-name">Base1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>derived <span class="token keyword">instanceof</span> <span class="token class-name">Base2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><h3 id="_8-4-서브클래스의-constructor"><a href="#_8-4-서브클래스의-constructor" class="header-anchor">#</a> 8-4. 서브클래스의 constructor</h3> <p>클래스에서 constructor를 생략하면 비어있는 constructor가 암묵적으로 정의됨</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>서브클래스에서 constructor 생략 시 클래스에 다음과 같은 constructor가 암묵적으로 정의됨</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 수퍼클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 서브클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 위 코드는 아래처럼 암묵적으로 constructor가 정의됨</span>
<span class="token comment">// 수퍼클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 서브클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> derived <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>derived<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Derived {}</span>
</code></pre></div><p>수퍼클래스와 서브클래스 모두 constructor 생략 시 빈 객체가 생성됨<br>
프로퍼티를 소유하는 인스턴스를 생성하려면 constructor 내부에서 인스턴스에 프로퍼티를 추가해야 함</p> <h3 id="_8-5-super-키워드"><a href="#_8-5-super-키워드" class="header-anchor">#</a> 8-5. super 키워드</h3> <ul><li>함수처럼 호출할 수도 있고, this와 같이 식별자처럼 참조할 수 있는 특수한 키워드</li> <li>super 키워드의 동작
<ul><li>super 호출 시 수퍼클래스의 constructor(super-constructor)를 호출함</li> <li>super 참조 시 수퍼클래스의 메서드를 호출 가능</li></ul></li></ul> <h4 id="super-호출"><a href="#super-호출" class="header-anchor">#</a> &lt;super 호출&gt;</h4> <ul><li><p><strong>super 호출 시 수퍼클래스의 constructor(super-constructor)를 호출함</strong></p> <ul><li><p><strong>서브클래스의 constructor 생략</strong><br>
수퍼클래스의 constructor내부에서 추가한 프로퍼티를 그대로 갖는 인스턴스를 생성하는 경우</p> <p>서브클래스의 constructor를 생략한 경우 new 연산자와 함께 서브클래스를 호출하면서 전달한 인수는<br>
서브클래스에 암묵적으로 정의된 constructor의 super 호출을 통해 수퍼클래스의 constructor에 전달됨</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 수퍼클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 서브클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token comment">// 다음과 같이 암묵적으로 constructor가 정의된다.</span>
<span class="token comment">// constructor(...args) { super(...args); }</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> derived <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>derived<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Derived {a: 1, b: 2}</span>
</code></pre></div></li> <li><p><strong>서브클래스의 constructor 생략 불가</strong><br>
수퍼클래스에서 추가한 프로퍼티와 서브클래스에서 추가한 프로퍼티를 갖는 인스턴스를 생성하는 경우</p> <p>new 연산자와 함께 서브 클래스를 호출하면서 전달한 인수 중 수퍼클래스의 constructor에<br>
전달할 필요 있는 인수는 서브 클래스의 constructor에서 호출하는 super를 통해 전달함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 수퍼클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ④</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 서브클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ②</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ③</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> c<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> derived <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ①</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>derived<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Derived {a: 1, b: 2, c: 3}</span>
</code></pre></div><p>이처럼 인스턴스 초기화를 위해 전달한 인수는 수퍼클래스와 서브클래스에 배분되고<br>
상속 관계의 두 클래스는 서로 협력해 인스턴스를 생성함</p></li></ul></li> <li><p>super 호출 시 주의할 점</p> <ul><li>서브클래스에서 constructor 생략하지 않는 경우<br>
서브 클래스의 constructor에서는 반드시 super를 호출해야 함</li> <li>서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조 불가능</li> <li>super는 반드시 서브클래스의 constructor에서만 호출<br>
서브클래스가 아닌 클래스의 constructor나 함수에서 super 호출 시 에러 발생함</li></ul></li></ul> <h4 id="super-참조"><a href="#super-참조" class="header-anchor">#</a> &lt;super 참조&gt;</h4> <p><strong>메서드 내에서 super 참조 시 수퍼클래스의 메서드 호출 가능</strong></p> <ul><li><p>서브클래스의 프로토타입 메서드 내에서 super.sayHi는 수퍼클래스의 프로토타입 메서드 sayHi를 가리킴</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 수퍼클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 서브클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// super.sayHi는 수퍼클래스의 프로토타입 메서드를 가리킨다.</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">. how are you doing?</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> derived <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>derived<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi! Lee. how are you doing?</span>
</code></pre></div><p>super 참조를 통해 수퍼클래스의 메서드를 참조하려면 super가<br>
수퍼클래스의 prototype 프로퍼티에 바인딩된 프로토타입을 참조할 수 있어야 함<br>
위 코드는 아래와 동일하게 동작함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 수퍼클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// __super는 Base.prototype을 가리킨다.</span>
    <span class="token keyword">const</span> __super <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">Derived</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>__super<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> how are you doing?</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>super는 자신을 참조하고 있는 메서드(Derived의 sayHi)가 바인딩되어 있는 객체(Derived.prototype)의<br>
프로토타입(Base.prototype)을 가리킴<br>
따라 super.sayHi는 Base.prototype.sayHi를 가리킴<br>
단, super.sayHi를 호출할 때 casll 메서드를 사용해 this를 전달해야 함</p> <p>call 메서드를 사용해 this를 전달하지 않고 super.sayHi를 그대로 호출하면<br>
Base.prototype.sayHi 메서드 내부의 this는 Base.prototype을 가리킴<br>
Base.prototype.sayHi 메서드는 프로토타입 메서드이기 떄문에 내부의 this는 인스턴스를 가리켜야 함<br>
(name 메서드는 인스턴스에 존재하므로)</p> <p>이처럼 super 참조가 동작하기 위해서는 super를 참조하고 있는 메서드가<br>
바인딩되어 있는 객체의 프로토타입을 찾을 수 있어야 함<br>
이를 위해 메서드는 내부 슬롯 [[HomeOjbect]]를 가지며, 자신을 바인딩하고 있는 객체를 가리킴</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*
[[HomeObject]]는 메서드 자신을 바인딩하고 있는 객체를 가리킨다.
[[HomeObject]]를 통해 메서드 자신을 바인딩하고 있는 객체의 프로토타입을 찾을 수 있다.
예를 들어, Derived 클래스의 sayHi 메서드는 Derived.prototype에 바인딩되어 있다.
따라서 Derived 클래스의 sayHi 메서드의 [[HomeObject]]는 Derived.prototype이고
이를 통해 Derived 클래스의 sayHi 메서드 내부의 super 참조가 Base.prototype으로 결정된다.
따라서 super.sayHi는 Base.prototype.sayHi를 가리키게 된다.
*/</span>
<span class="token keyword">super</span> <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>HomeObject<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>주의할 것은 ES6의 메서드 축약 표현으로 정의된 함수만이 [[HomeObject]]를 갖는다는 것</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// foo는 ES6의 메서드 축약 표현으로 정의한 메서드다. 따라서 [[HomeObject]]를 갖는다.</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token comment">// bar는 ES6의 메서드 축약 표현으로 정의한 메서드가 아니라 일반 함수다.</span>
  <span class="token comment">// 따라서 [[HomeObject]]를 갖지 않는다.</span>
  <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>따라 [[HomeObject]]를 가지는 ES6의 메서드 축약 표현으로 정의된 함수만이 super를 참조가능함<br>
단, super 참조는 수퍼클래스의 메서드를 참조하기 위해 사용하므로 서브클래스의 메서드에서 사용해야 함</p> <p>super 참조는 클래스의 전유물은 아님<br>
객체 리터럴에서도 super 참조 가능함. 단 ES6의 메서드 축약 표현으로 정의된 함수만 가능</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> base <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Lee'</span><span class="token punctuation">,</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> derived <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">__proto__</span><span class="token operator">:</span> base<span class="token punctuation">,</span>  
  <span class="token comment">// ES6 메서드 축약 표현으로 정의한 메서드. 따라서 [[HomeObject]]를 갖는다.</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">. how are you doing?</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>derived<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi! Lee. how are you doing?</span>
</code></pre></div></li> <li><p>서브클래스의 정적 메서드 내에서 super.sayHi는 수퍼클래스의 정적 메서드 sayHi를 가리킴</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 수퍼클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'Hi!'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 서브클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// super.sayHi는 수퍼클래스의 정적 메서드를 가리킨다.</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> how are you doing?</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Derived<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi! how are you doing?</span>
</code></pre></div></li></ul> <h3 id="_8-6-상속-클래스의-인스턴스-생성-과정"><a href="#_8-6-상속-클래스의-인스턴스-생성-과정" class="header-anchor">#</a> 8-6. 상속 클래스의 인스턴스 생성 과정</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 수퍼클래스</span>
<span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">width<span class="token punctuation">,</span> height</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> width<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>height<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">width = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>width<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, height = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>height<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 서브클래스</span>
<span class="token keyword">class</span> <span class="token class-name">ColorRectangle</span> <span class="token keyword">extends</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 메서드 오버라이딩</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">, color = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> colorRectangle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ColorRectangle</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>colorRectangle<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ColorRectangle {width: 2, height: 4, color: &quot;red&quot;}</span>
<span class="token comment">// 상속을 통해 getArea 메서드를 호출</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>colorRectangle<span class="token punctuation">.</span><span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>
<span class="token comment">// 오버라이딩된 toString 메서드를 호출</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>colorRectangle<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// width = 2, height = 4, color = red</span>
</code></pre></div><p>서브클래스 ColorRectangle이 new 연산자와 함께 호출되면 다음 과정을 통해 인스턴스를 생성함</p> <ol><li><p><strong>서브클래스의 super 호출</strong><br>
자바스크립트 엔진은 클래스 평가 시 수퍼클래스/서브클래스를 구분하기 위해<br>
'base' or 'derived'를 값으로 갖는 내부 슬롯 [[ConstructorKind]]를 가짐<br>
다른 클래스를 상속받지 않는 클래스(그리고 생성자 함수)는 값이 'base'로 설정되지만,<br>
다른 클래스를 상속받는 서브클래스는 값이 'derived'로 설정됨<br>
이를 통해 수퍼클래스와 서브클래스는 new 연산자와 함께 호출되었을 때 동작이 구분됨</p> <p>다른 클래스를 상속받지 않는 클래스는 new 연산자와 함께 호출되었을 때<br>
암묵적으로 빈 객체를 생성하고 이를 this에 바인딩함<br>
하지만 <strong>서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에 인스턴스 생성을 위임함</strong><br>
(서브클리스의 constructor에서 반드시 super를 호출해야 하는 이유)</p> <p>서브클래스가 new 연산자와 함께 호출되면 서브클래스 constructor 내부의 super 키워드가 함수처럼 호출됨<br>
super가 호출되면 수퍼클래스의 constructor가 호출됨<br>
좀 더 정확히 말하면 수퍼클래스가 평가되어 생성된 함수 객체의 코드가 실행되기 시작함</p> <p>만약 수퍼클래스 constructor 내부에 super 호출이 없으면 에러 발생함<br>
실제로 인스턴스를 생성하는 주체는 수퍼클래스이므로 수퍼클래스의 constructor를<br>
호출하는 super가 호출되지 않으면 인스턴스를 생성할 수 없기 때문</p></li> <li><p><strong>수퍼클래스의 인스턴스 생성과 this 바인딩</strong><br>
수퍼클래스의 constructor 내부의 코드가 실행되기 이전에<br>
암묵적으로 빈 객체(클래스가 생성한 인스턴스)를 생성하며 해당 빈 객체는 this에 바인딩 됨<br>
따라서 수퍼클래스의 constructor 내부의 this는 생성된 인스턴스를 가리킨다.</p> <p>이때 인스턴스는 수퍼클래스가 생성한 것<br>
하지만 new 연산자와 함께 호출된 클래스가 서브클래스라는 것이 중요함<br>
즉, new 연산자와 함께 호출된 함수를 가리키는 new.target은 서브클래스를 가리킴<br>
때문에 인스턴스는 new.target이 가리키는 서브클래스가 생성한 것으로 처리됨</p> <p>따라 생성된 인스턴스의 프로토타입은 수퍼클래스의 prototype 프로퍼티가 가리키는 객체가 아닌<br>
new.target, 즉 서브클래스의 prototype 프로퍼티가 가리키는 객체</p></li> <li><p><strong>수퍼클래스의 인스턴스 초기화</strong><br>
수퍼클래스의 constructor가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화함<br>
즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고<br>
constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화함</p></li> <li><p><strong>서브클래스 constructor로의 복귀와 this 바인딩</strong><br>
super의 호출이 종료되고 제어 흐름이 서브클래스 constructor로 돌아옴<br>
이때 super가 반환한 인스턴스가 this에 바인딩됨<br>
서브클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩해 그대로 사용함</p> <p>super가 호출되지 않으면 인스턴스가 생성되지 않으며, this 바인딩도 할 수 없음<br>
서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없는 이유가 바로 이 때문<br>
따라서 서브클래스 constructor 내부의 인스턴스 초기화는 반드시 super 호출 이후에 처리되어야 함</p></li> <li><p><strong>서브클래스의 인스턴스 초기화</strong><br>
super 호출 이후, 서브클래스의 constructor에 기술되어 있는 인스턴스 초기화가 실행됨<br>
즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고<br>
constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화함</p></li> <li><p><strong>인스턴스 반환</strong><br>
클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환됨</p></li></ol> <h3 id="_8-7-표준-빌트인-생성자-함수-확장"><a href="#_8-7-표준-빌트인-생성자-함수-확장" class="header-anchor">#</a> 8-7. 표준 빌트인 생성자 함수 확장</h3> <p>extends 키워드 다음에는 클래스뿐 아니라 [[Construct]] 내부 메서드를 갖는<br>
함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있음<br>
표준 빌트인 객체도 [[Construct]] 내부 메서드를 갖는 생성자 함수이므로 가능</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Array 생성자 함수를 상속받아 확장한 MyArray</span>
<span class="token keyword">class</span> <span class="token class-name">MyArray</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span> <span class="token punctuation">{</span>
  <span class="token comment">// 중복된 배열 요소를 제거하고 반환한다: [1, 1, 2, 3] =&gt; [1, 2, 3]</span>
  <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> i<span class="token punctuation">,</span> self</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> self<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">===</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 모든 배열 요소의 평균을 구한다: [1, 2, 3] =&gt; 2</span>
  <span class="token function">average</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> pre <span class="token operator">+</span> cur<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> myArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// MyArray(4) [1, 1, 2, 3]</span>
<span class="token comment">// MyArray.prototype.uniq 호출</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myArray<span class="token punctuation">.</span><span class="token function">uniq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// MyArray(3) [1, 2, 3]</span>
<span class="token comment">// MyArray.prototype.average 호출</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myArray<span class="token punctuation">.</span><span class="token function">average</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1.75</span>
</code></pre></div><p>Array 생성자 함수를 상속받아 확장한 MyArray 클래스가 생성한 인스턴스는<br>
Array.prototype과 MyArray.prototype의 모든 메서드를 사용할 수 있음</p> <p>이때 주의할 것은 Array.prototype의 메서드 중 map, filter와 같이 새로운 배열을 반환하는 메서드가<br>
MyArray 클래스의 인스턴스를 반환한다는 것</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myArray<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> v <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">MyArray</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>만약 새로운 배열을 반환하는 메서드가 MyArray 클래스의 인스턴스를 반환하지 않고<br>
Array의 인스턴스를 반환하면 MyArray 클래스의 메서드와 메서드 체이닝이 불가능함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 메서드 체이닝</span>
<span class="token comment">// [1, 1, 2, 3] =&gt; [ 1, 1, 3 ] =&gt; [ 1, 3 ] =&gt; 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myArray<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> v <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">uniq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">average</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>myArray.filter가 반환하는 인스턴스는 MyArray 클래스가 생성한 인스턴스, 즉 MyArray 타입<br>
따라 myArray.filter가 반환하는 인스턴스로 uniq 메서드를 연이어 호출(메서드 체이닝)할 수 있음</p> <p>uniq 메서드가 반환하는 인스턴스는 Array.prototype.filter에 의해 생성되었기 때문에<br>
Array 생성자 함수가 생성한 인스턴스로 생각할 수도 있지만<br>
uniq 메서드가 반환하는 인스턴스도 MyArray 타입이므로<br>
uniq 메서드가 반환하는 인스턴스로 average 메서드를 연이어 호출(메서드 체이닝)할 수 있음</p> <p>만약 MyArray 클래스의 uniq 메서드가 MyArray 클래스가 생성한 인스턴스가 아닌<br>
Array가 생성한 인스턴스를 반환하게 하려면 Symbol.species를 사용하여 정적 접근자 프로퍼티를 추가함</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Array 생성자 함수를 상속받아 확장한 MyArray</span>
<span class="token keyword">class</span> <span class="token class-name">MyArray</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span> <span class="token punctuation">{</span>  
  <span class="token comment">// 모든 메서드가 Array 타입의 인스턴스를 반환하도록 한다.</span>
  <span class="token keyword">static</span> <span class="token keyword">get</span> <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>species<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Array<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 중복된 배열 요소를 제거하고 반환한다: [1, 1, 2, 3] =&gt; [1, 2, 3]</span>
  <span class="token function">uniq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> i<span class="token punctuation">,</span> self</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> self<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">===</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 모든 배열 요소의 평균을 구한다: [1, 2, 3] =&gt; 2</span>
  <span class="token function">average</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> pre <span class="token operator">+</span> cur<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> myArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myArray<span class="token punctuation">.</span><span class="token function">uniq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">MyArray</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myArray<span class="token punctuation">.</span><span class="token function">uniq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// 메서드 체이닝</span>
<span class="token comment">// uniq 메서드는 Array 인스턴스를 반환하므로 average 메서드를 호출할 수 없다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myArray<span class="token punctuation">.</span><span class="token function">uniq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">average</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// TypeError: myArray.uniq(...).average is not a function</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/TIL/assets/js/app.e4018421.js" defer></script><script src="/TIL/assets/js/2.f771dbe5.js" defer></script><script src="/TIL/assets/js/68.c297e89c.js" defer></script>
  </body>
</html>
